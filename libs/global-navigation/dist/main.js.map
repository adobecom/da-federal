{
  "version": 3,
  "sources": ["../src/Error/Error.ts", "../src/Utils/Utils.ts", "../src/Components/Brand/Parse.ts", "../src/Components/Brand/brand.css", "../src/Components/Brand/Render.ts", "../src/Components/Link/Parse.ts", "../src/Components/CTA/Parse.ts", "../src/Components/CTA/Render.ts", "../src/Components/Link/Render.ts", "../src/Components/LinkGroup/Parse.ts", "../src/Components/Tab/Parse.ts", "../src/Components/MegaMenu/Parse.ts", "../src/Components/MegaMenu/Render.ts", "../src/Components/SmallMenu/Parse.ts", "../src/Components/LinkGroup/Render.ts", "../src/Components/Tab/Render.ts", "../src/Components/SmallMenu/Render.ts", "../src/Components/Text/Parse.ts", "../src/Components/Text/Render.ts", "../src/Components/Component.ts", "../src/Parse/Parse.ts", "../src/PostRendering/ClickListeners.ts", "../src/PostRendering/Keyboard.ts", "../src/PreRendering/FetchAssets.ts", "../src/styles/styles.css", "../src/Main.ts"],
  "sourcesContent": ["export class IrrecoverableError extends Error {\n  constructor(message: string) {\n    super(message);\n    // This is important for proper instanceof checks\n    Object.setPrototypeOf(this, IrrecoverableError.prototype);\n    // TODO: Lana logging logic can go here\n  }\n}\n\ntype Severity\n  = \"Minor\"\n  | \"Major\"\n  | \"Critical\"\n\nexport class RecoverableError extends Error {\n  constructor(message: string, severity: Severity = \"Minor\") {\n    super(message);\n    // This is important for proper instanceof checks\n    Object.setPrototypeOf(this, RecoverableError.prototype);\n    if (severity !== \"Minor\") {\n      // TODO: Lana logging logic can go here\n    }\n  }\n}\n", "import { IrrecoverableError } from \"../Error/Error\";\n\nexport const isDesktop = window.matchMedia('(min-width: 900px)');\n\nexport const icons = {\n  brand: '<svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" id=\"Layer_1\" viewBox=\"0 0 64.57 35\"><defs><style>.cls-1{fill: #eb1000;}</style></defs><path class=\"cls-1\" d=\"M6.27,10.22h4.39l6.2,14.94h-4.64l-3.92-9.92-2.59,6.51h3.08l1.23,3.41H0l6.27-14.94ZM22.03,13.32c.45,0,.94.04,1.43.16v-3.7h3.88v14.72c-.89.4-2.81.89-4.73.89-3.48,0-6.47-1.98-6.47-5.93s2.88-6.13,5.89-6.13ZM22.52,22.19c.36,0,.65-.07.94-.16v-5.42c-.29-.11-.58-.16-.96-.16-1.27,0-2.45.94-2.45,2.92s1.2,2.81,2.47,2.81ZM34.25,13.32c3.23,0,5.98,2.18,5.98,6.02s-2.74,6.02-5.98,6.02-6-2.18-6-6.02,2.72-6.02,6-6.02ZM34.25,22.13c1.11,0,2.14-.89,2.14-2.79s-1.03-2.79-2.14-2.79-2.12.89-2.12,2.79.96,2.79,2.12,2.79ZM41.16,9.78h3.9v3.7c.47-.09.96-.16,1.45-.16,3.03,0,5.84,1.98,5.84,5.86,0,4.1-2.99,6.18-6.53,6.18-1.52,0-3.46-.31-4.66-.87v-14.72ZM45.91,22.17c1.34,0,2.56-.96,2.56-2.94,0-1.85-1.2-2.72-2.5-2.72-.36,0-.65.04-.91.16v5.35c.22.09.51.16.85.16ZM58.97,13.32c2.92,0,5.6,1.87,5.6,5.64,0,.51-.02,1-.09,1.49h-7.27c.4,1.32,1.56,1.94,3.01,1.94,1.18,0,2.27-.29,3.5-.82v2.97c-1.14.58-2.5.82-3.9.82-3.7,0-6.58-2.23-6.58-6.02s2.61-6.02,5.73-6.02ZM60.93,18.02c-.2-1.27-1.05-1.78-1.92-1.78s-1.58.54-1.87,1.78h3.79Z\"/></svg>',\n  company: '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"22\" viewBox=\"0 0 24 22\" fill=\"none\"><path d=\"M14.2353 21.6209L12.4925 16.7699H8.11657L11.7945 7.51237L17.3741 21.6209H24L15.1548 0.379395H8.90929L0 21.6209H14.2353Z\" fill=\"#EB1000\"/></svg>',\n  search: '<svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" focusable=\"false\"><path d=\"M14 2A8 8 0 0 0 7.4 14.5L2.4 19.4a1.5 1.5 0 0 0 2.1 2.1L9.5 16.6A8 8 0 1 0 14 2Zm0 14.1A6.1 6.1 0 1 1 20.1 10 6.1 6.1 0 0 1 14 16.1Z\"></path></svg>',\n  home: '<svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" height=\"25\" viewBox=\"0 0 18 18\" width=\"25\"><path fill=\"#6E6E6E\" d=\"M17.666,10.125,9.375,1.834a.53151.53151,0,0,0-.75,0L.334,10.125a.53051.53051,0,0,0,0,.75l.979.9785A.5.5,0,0,0,1.6665,12H2v4.5a.5.5,0,0,0,.5.5h4a.5.5,0,0,0,.5-.5v-5a.5.5,0,0,1,.5-.5h3a.5.5,0,0,1,.5.5v5a.5.5,0,0,0,.5.5h4a.5.5,0,0,0,.5-.5V12h.3335a.5.5,0,0,0,.3535-.1465l.979-.9785A.53051.53051,0,0,0,17.666,10.125Z\"/></svg>',\n};\n\n// split arrays based on a predicate\n// unlike string.prototype.split, it works on\n// all arrays.\nexport const split = <T>(\n  predicate: (_: T) => boolean\n) => (arr: T[]): T[][] => {\n  const splitArrays = [];\n  let currSubArray = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (predicate(arr[i])) {\n      splitArrays.push(currSubArray);\n      currSubArray = [];\n      continue;\n    }\n    currSubArray.push(arr[i]);\n  }\n  splitArrays.push(currSubArray);\n  return splitArrays;\n};\n\nexport const zip = <T, R>(\n  xs: T[],\n  ys: R[]\n): List<[T, R]> => {\n  const len = xs.length < ys.length\n            ? xs.length\n            : ys.length;\n  const result = new Array(len) as List<[T, R]>;\n  for (let i = 0; i < len; i = i + 1) {\n    result[i] = [xs[i], ys[i]];\n  }\n  return result;\n}\n\nexport const takeWhile = <T>(\n  predicate: (_: T) => boolean\n) => (arr: T[]): T[] => {\n  if (arr.length === 0)\n    return arr;\n  const [firstItem, ...remainingItems] = arr;\n  if (predicate(firstItem))\n    return [firstItem].concat(takeWhile(predicate)(remainingItems));\n  return [];\n};\n\nexport const dropWhile = <T>(\n  predicate: (_: T) => boolean\n) => (arr: T[]): T[] => {\n  if (arr.length === 0)\n    return arr;\n  const [firstItem, ...remainingItems] = arr;\n  if (predicate(firstItem))\n    return dropWhile(predicate)(remainingItems);\n  return remainingItems;\n};\n\nexport const getNextSiblings = (element: Element): Element[] => {\n  const accumulator = [];\n  let iterator = element.nextElementSibling as Element ?? null;\n  while(iterator !== null) {\n    accumulator.push(iterator);\n    iterator = iterator.nextElementSibling as Element ?? null;\n  }\n  return accumulator;\n};\n\ntype Alternative<ReturnType, InputType> = {\n  or: (\n    fallbackFn: (input: InputType) => ReturnType\n  ) => Alternative<ReturnType, InputType>;\n  eval: (input: InputType) => ReturnType;\n};\n\nexport const alternative = <ReturnType, InputType>(\n  primaryFn: (input: InputType) => ReturnType\n): Alternative<ReturnType, InputType> => {\n  return {\n    eval: primaryFn,\n    or: (fallbackFn) => alternative((input) => {\n      try {\n        return primaryFn(input)\n      } catch (_error) {\n        return fallbackFn(input);\n      }\n    })\n  }\n};\n\nexport const parseListAndAccumulateErrors = <\n  UnParsedObj,\n  ParsedObj,\n  ErrorType\n  >(\n  elements: List<UnParsedObj>,\n  parse: (element: UnParsedObj) => Parsed<ParsedObj, ErrorType>\n): Parsed<List<ParsedObj>, ErrorType> => elements.reduce(\n  ([accElems, accErrors], element) => {\n    try {\n      const [parsedElement, parseErrors] = parse(element);\n      return [\n        [...accElems, parsedElement],\n        [...accErrors, ...parseErrors]\n      ];\n    } catch (error) {\n      if (error instanceof IrrecoverableError) {\n        return [accElems, [\n          error as ErrorType,\n          ...accErrors]\n        ];\n      }\n      return [accElems, accErrors];\n    }\n  },\n  [[],[]] as Parsed<List<ParsedObj>, ErrorType>\n  );\n\ntype CleanupFunction = () => void;\ntype AddListeners = (gnav: HTMLElement) => CleanupFunction;\ntype ListenerSetupFunctions = {\n  mobileEventListeners: AddListeners;\n  desktopEventListeners: AddListeners;\n}\nexport const setupMobileDesktopListeners = ({\n  mobileEventListeners,\n  desktopEventListeners\n}: ListenerSetupFunctions) => (gnav: HTMLElement): void => {\n  let cleanup: CleanupFunction;\n  if (isDesktop.matches)\n    cleanup = desktopEventListeners(gnav);\n  else\n    cleanup = mobileEventListeners(gnav);\n\n  isDesktop.addEventListener('change', () => {\n    cleanup?.();\n    cleanup\n      = isDesktop.matches\n      ? desktopEventListeners(gnav)\n      : mobileEventListeners(gnav);\n  });\n};\n\nexport const fetchAndProcessPlainHTML = async (\n  source: URL | null\n): Promise<HTMLElement | IrrecoverableError> => {\n  try {\n    if (source === null)\n      return new IrrecoverableError('URL is null');\n    const modifiedSource = federateUrl(`${source.origin}${source.pathname.replace(/(\\.html$|$)/, '.plain.html')}${source.hash}`);\n    const response = await fetch(modifiedSource);\n    if (!response.ok)\n      return new IrrecoverableError(`Request for ${modifiedSource} failed`);\n    const htmlText = await response.text();\n  \n    const { body } = new DOMParser().parseFromString(htmlText, \"text/html\");\n    return body;\n  } catch (error) {\n    // @ts-expect-error errors usually have a message\n    return new IrrecoverableError(error?.message);\n  }\n};\n\n// TODO: refactor\nlet federatedContentRoot: string;\nexport const getFederatedContentRoot = (): string => {\n  if (federatedContentRoot) return federatedContentRoot;\n\n  const cdnWhitelistedOrigins = [\n    'https://www.adobe.com',\n    'https://business.adobe.com',\n    'https://blog.adobe.com',\n    'https://milo.adobe.com',\n    'https://news.adobe.com',\n    'graybox.adobe.com',\n  ];\n  if (federatedContentRoot) return federatedContentRoot;\n  // Non milo consumers will have its origin from config\n  // TODO: allow the passing of a configured origin\n  const origin = window.location.origin;\n\n  const isAllowedOrigin = cdnWhitelistedOrigins.some((o) => {\n    const originNoStage = origin.replace('.stage', '');\n    return o.startsWith('https://')\n      ? originNoStage === o\n      : originNoStage.endsWith(o);\n  });\n\n  federatedContentRoot = isAllowedOrigin ? origin : 'https://www.adobe.com';\n\n  const SLD = window.location.hostname.includes('.aem.') ? 'aem' : 'hlx';\n  if (origin.includes('localhost') || origin.includes(`.${SLD}.`)) {\n    federatedContentRoot = `https://main--federal--adobecom.aem.${origin.endsWith('.live') ? 'live' : 'page'}`;\n  }\n\n  return federatedContentRoot;\n};\n\n// TODO we should match the akamai patterns /locale/federal/\n// at the start of the url\n// and make the check more strict.\nexport const federateUrl = (url = ''): string => {\n  if (typeof url !== 'string' || !url.includes('/federal/')) return url;\n  if (url.startsWith('/')) return `${getFederatedContentRoot()}${url}`;\n  try {\n    const { pathname, search, hash } = new URL(url);\n    return `${getFederatedContentRoot()}${pathname}${search}${hash}`;\n  } catch (e) {\n    // @ts-expect-error errors usually have a message\n    console.log(`getFederatedUrl errored parsing the URL: ${url}: ${e?.message}`);\n  }\n  return url;\n};\n\nexport const inlineNestedFragments = async (\n  element: Element | HTMLElement\n): Promise<Element | HTMLElement | IrrecoverableError> => {\n  const processElement = async (\n    currentElem: Element | HTMLElement | IrrecoverableError,\n    visitedUrls: Set<string>\n  ): Promise<Element | HTMLElement | IrrecoverableError> => {\n    if (currentElem instanceof IrrecoverableError)\n      return currentElem;\n    try {\n      const anchorElements = [\n        ...currentElem.querySelectorAll('a[href*=\"#_inline\"]')\n      ] as HTMLAnchorElement[];\n      const inlineLinks = anchorElements\n        .map(async (anchorElement: HTMLAnchorElement) => {\n          try {\n            if (visitedUrls.has(anchorElement.href)) return;\n            const federatedUrl = federateUrl(anchorElement.href);\n            const fragmentUrl = new URL(federatedUrl);\n            const fragmentBody = await fetchAndProcessPlainHTML(fragmentUrl);\n            visitedUrls.add(anchorElement.href);\n            if (fragmentBody instanceof IrrecoverableError)\n              throw fragmentBody;\n            await processElement(fragmentBody, visitedUrls);\n            const parentDiv = anchorElement.closest('div');\n            if (parentDiv) {\n              parentDiv.replaceWith(...fragmentBody.children);\n            } else {\n              anchorElement.replaceWith(...fragmentBody.children);\n            }\n            return;\n          } catch {\n            return;\n          }\n        }, [] as List<[HTMLAnchorElement, URL]>)\n      await Promise.all(inlineLinks);\n      return currentElem\n    } catch (error) {\n      return new IrrecoverableError(JSON.stringify(error));\n    }\n  }\n  return processElement(element, new Set());\n};\n\nexport const renderListItems = <T>(\n  items: T[],\n  renderFn: (item: T) => string\n): string => {\n  return items.map(item => `<li>${renderFn(item)}</li>`).join('');\n};\n\nexport const sanitize = (str: string): string => {\n  return str\n    .toLowerCase()\n    .trim()\n    // Replace spaces and non-alphanumeric characters with hyphens\n    .replace(/[^a-z0-9]/g, '-')\n    // Remove multiple consecutive hyphens\n    .replace(/-+/g, '-')\n    // Remove leading/trailing hyphens\n    .replace(/^-+|-+$/g, '')\n    // Ensure it starts with a letter (prepend 'id-' if it starts with a number)\n    .replace(/^(\\d)/, 'id-$1')\n};\n\n\nexport const isDarkMode = (): boolean => {\n  // TODO: Implement dark mode detection\n  return true;\n};\n", "import { IrrecoverableError, RecoverableError } from \"../../Error/Error\";\nimport { icons, isDarkMode } from \"../../Utils/Utils\";\n\ntype ImageData =\n  | { type: 'inline-svg'; svgContent: string; alt: string }\n  | { type: 'image'; src: string; alt: string };\n\nexport type Brand = {\n  type: 'Brand';\n  data: { type: 'LabelledBrand'; href: string; label: string; image: ImageData }\n  | { type: 'BrandImageOnly'; href: string; image: ImageData; alt: string }\n  | { type: 'ImageOnlyBrand'; href: string; image: ImageData; alt: string }\n  | { type: 'BrandLabelOnly'; href: string; label: string }\n  | { type: 'NoRender' };\n};\nconst ERRORS = {\n  elementNull: \"Error when parsing Brand. Element is null\",\n  noLinks: \"Error when parsing Brand. No links found\",\n  noPrimaryLink: \"Error when parsing Brand. No primary link found\",\n};\n\nconst IMG_REGEX = /(\\.png|\\.jpg|\\.jpeg|\\.svg)/i;\n\n/**\n * Extracts image source from a link element or picture element\n */\nconst extractImageSource = (element: Element): string | null => {\n  const imgSrc = element.querySelector('picture img')?.getAttribute('src') ?? null;\n  if (imgSrc !== null && imgSrc !== '') return imgSrc;\n\n  const text = element.textContent?.trim();\n  if (text !== undefined && text !== '' && IMG_REGEX.test(text)) {\n    const source = text.split('|')[0]?.trim();\n    if (source !== undefined && source !== '') return source;\n  }\n\n  const href = element.getAttribute('href');\n  return href !== null && href !== '' && IMG_REGEX.test(href) ? href : null;\n};\n\n/**\n * Extracts alt text from image content\n */\nconst extractAltText = (element: Element): string => {\n  const text = element.textContent?.trim();\n\n  if (text?.includes('|') === true) {\n    const alt = text.split('|')[1]?.trim();\n    if (alt) return alt;\n  }\n\n  const altAttr = element.querySelector('img')?.getAttribute('alt');\n  return altAttr ?? '';\n};\n\nexport const parseBrand = (\n  element: Element | null,\n): Parsed<Brand, RecoverableError> => {\n  if (element === null) {\n    throw new IrrecoverableError(ERRORS.elementNull);\n  }\n\n  const rawBlock = element.querySelector('.gnav-brand');\n  if (rawBlock === null) {\n    throw new IrrecoverableError(ERRORS.elementNull);\n  }\n\n  const blockLinks = [...rawBlock.querySelectorAll('a')] as HTMLAnchorElement[];\n  if (blockLinks.length === 0) {\n    throw new IrrecoverableError(ERRORS.noLinks);\n  }\n\n  // Find the primary (non-image) link\n  const primaryLink = blockLinks.find((link) => {\n    const textContent = link.textContent ?? '';\n    return !IMG_REGEX.test(link.href) && !IMG_REGEX.test(textContent);\n  });\n\n  if (!primaryLink) {\n    throw new IrrecoverableError(ERRORS.noPrimaryLink);\n  }\n\n  // Determine rendering flags based on CSS classes\n  const isBrandImageOnly = rawBlock.matches('.brand-image-only');\n  const noLogo = rawBlock.matches('.no-logo');\n  const imageOnly = rawBlock.matches('.image-only');\n  const renderImage = !noLogo;\n  const renderLabel = !isBrandImageOnly && !imageOnly;\n\n  // Get image links for extracting image sources and alt text\n  const imageLinks = blockLinks.filter((link) => {\n    const textContent = link.textContent ?? '';\n    return IMG_REGEX.test(link.href) || IMG_REGEX.test(textContent);\n  });\n\n  // Extract image sources (light and dark mode) and alt text\n  const [imgSrc, imgSrcDark, altText] = ((): [\n    string, \n    string | null, \n    string\n  ] => {\n    const defaultImgSrc = isBrandImageOnly ? icons.brand : icons.company;\n  \n    const [svgImgSrc = null, svgDarkImgSrc = null] = ([...rawBlock.querySelectorAll('picture img[src$=\".svg\"]')] as HTMLImageElement[])\n      .map((img) => img?.src)\n      .filter((src) => src?.length > 0);\n  \n    const [imgSrc = null, imgSrcDark = null] = \n      imageLinks.map(extractImageSource);\n    const altText = imageLinks[0] instanceof Element\n                  ? extractAltText(imageLinks[0])\n                  : primaryLink.textContent?.trim() ?? '';\n  \n    return [\n      imgSrc ?? svgImgSrc ?? defaultImgSrc,\n      imgSrcDark ?? svgDarkImgSrc,\n      altText\n    ];\n  })();\n\n  const label = primaryLink.textContent?.trim() ?? '';\n  const href = primaryLink.href;\n\n  if (!renderImage && !renderLabel) return [{ type: 'Brand', data: { type: 'NoRender' } }, []];\n\n  const selectSource = (light: string, dark: string | null): string => {\n    const hasDark = dark !== null && dark !== undefined && dark !== '';\n    return isDarkMode() && hasDark ? dark : light;\n  };\n\n  const imageData: ImageData = imgSrc.startsWith('<svg')\n    ? { type: 'inline-svg', svgContent: selectSource(imgSrc, imgSrcDark), alt: altText }\n    : { type: 'image', src: selectSource(imgSrc, imgSrcDark), alt: altText };\n\n  if (renderImage && renderLabel) {\n    return [{ type: 'Brand', data: { type: 'LabelledBrand', href, label, image: imageData } }, []];\n  }\n\n  if (renderImage && isBrandImageOnly) {\n    return [{ type: 'Brand', data: { type: 'BrandImageOnly', href, image: imageData, alt: altText } }, []];\n  }\n\n  if (renderImage && imageOnly) {\n    return [{ type: 'Brand', data: { type: 'ImageOnlyBrand', href, image: imageData, alt: altText } }, []];\n  }\n\n  return [{ type: 'Brand', data: { type: 'BrandLabelOnly', href, label } }, []];\n};\n", "\n        const css = \".feds-brand-container {\\n    display: flex;\\n    flex-shrink: 0;\\n}\\n\\n.feds-brand {\\n    display: flex;\\n}\\n\\n.feds-brand,\\n.feds-logo {\\n    align-items: center;\\n    outline-offset: 2px;\\n    padding: 0 var(--feds-gutter);\\n    column-gap: 10px;\\n}\\n\\n.feds-brand-image,\\n.feds-logo-image {\\n    width: 25px;\\n    flex-shrink: 0;\\n}\\n\\n.feds-brand-image.brand-image-only {\\n    height: 36px;\\n    width: auto;\\n    min-width: 66px;\\n}\\n\\n.feds-brand-image.brand-image-only picture,\\n.feds-brand-image.brand-image-only img,\\n.feds-brand-image.brand-image-only svg {\\n    width: auto;\\n    height: 100%;\\n}\\n\\n.feds-brand-image picture,\\n.feds-brand-image img,\\n.feds-brand-image svg,\\n.feds-logo-image picture,\\n.feds-logo-image img,\\n.feds-logo-image svg {\\n    width: 100%;\\n    display: block;\\n}\\n\\n.feds-brand-label,\\n.feds-logo-label {\\n    flex-shrink: 0;\\n    font-weight: 700;\\n    font-size: 18px;\\n    color: var(--feds-color-adobeBrand);\\n}\\n\\n@media (min-width: 900px) {\\n    .feds-brand-image+.feds-brand-label {\\n        display: flex;\\n    }\\n}\";\n        const style = document.createElement('style');\n        style.textContent = css;\n        document.head.appendChild(style);\n      ", "import { Brand } from \"./Parse\";\nimport './brand.css';\n\ntype ImageData = Extract<Brand['data'], { image: unknown }>['image'];\n\nconst renderImage = (image: ImageData, imageOnly: boolean): string => {\n  const cls = `feds-brand-image${imageOnly ? ' brand-image-only' : ''}`;\n  \n  if (image.type === 'inline-svg') {\n    return `<span class=\"${cls}\">${image.svgContent}</span>`;\n  }\n\n  const alt = image.alt ? ` alt=\"${image.alt}\"` : '';\n  return `<span class=\"${cls}\"><img src=\"${image.src}\"${alt} /></span>`;\n};\n\nconst renderBrand = (href: string, content: string, ariaLabel = ''): HTML =>\n  `<div class=\"feds-brand-container\">\n    <a href=\"${href}\" class=\"feds-brand\" daa-ll=\"Brand\"${ariaLabel}>\n      ${content}\n    </a>\n  </div>`.trim();\n\nexport const brand = (brandData: Brand): HTML => {\n  const { data } = brandData;\n  switch (data.type) {\n    case 'LabelledBrand':\n      return renderBrand(\n        data.href,\n        renderImage(data.image, false) +\n        `<span class=\"feds-brand-label\">${data.label}</span>`\n      );\n\n    case 'BrandImageOnly': {\n      const aria = data.alt ? ` aria-label=\"${data.alt}\"` : '';\n      return renderBrand(\n        data.href,\n        renderImage(data.image, true),\n        aria\n      );\n    }\n\n    case 'ImageOnlyBrand': {\n      const aria = data.alt ? ` aria-label=\"${data.alt}\"` : '';\n      return renderBrand(\n        data.href,\n        renderImage(data.image, false),\n        aria\n      );\n    }\n\n    case 'BrandLabelOnly':\n      return renderBrand(\n        data.href,\n        `<span class=\"feds-brand-label\">${data.label}</span>`\n      );\n\n    case 'NoRender':\n      return '';\n\n    default:\n      data satisfies never;\n      return '';\n  }\n};", "import { IrrecoverableError, RecoverableError } from \"../../Error/Error\";\n\nexport type Link = {\n  type: 'Link';\n  text: string;\n  href: string;\n};\n\nconst ERRORS = {\n  elementNull: \"Error when parsing Link. Element is null\",\n  notAnchor: \"Cannot parse non-anchor as Link\",\n  textContentNotFound: \"Error when parsing Link. Element has no textContent\",\n  hrefNotFound: \"Element has no href\",\n}\n\nexport const parseLink = (\n  anchor: Element | null\n): Parsed<Link, RecoverableError> => {\n  if (anchor === null)\n    throw new IrrecoverableError(ERRORS.elementNull);\n\n  if (anchor.tagName !== 'A')\n    throw new IrrecoverableError(ERRORS.notAnchor);\n\n  const text = anchor?.textContent ?? '';\n  if (text === '')\n    throw new IrrecoverableError(ERRORS.textContentNotFound)\n\n  const href = anchor?.getAttribute(\"href\") ?? '';\n  if (href === '')\n    throw new IrrecoverableError(ERRORS.hrefNotFound);\n\n  return [\n    {\n      type: \"Link\",\n      text,\n      href\n    },\n    []\n  ];\n};\n", "import { RecoverableError } from \"../../Error/Error\";\nimport { alternative } from \"../../Utils/Utils\";\nimport { parseLink } from \"../Link/Parse\";\n\nexport type PrimaryCTA = {\n  type: \"PrimaryCTA\";\n  text: string;\n  href: string;\n};\n\nexport type SecondaryCTA = {\n  type: \"SecondaryCTA\";\n  text: string;\n  href: string;\n};\n\nexport type ProductEntryCTA = PrimaryCTA | SecondaryCTA;\n\nconst parseCTA = (\n  type: Pick<CTA, 'type'>\n) => (\n  element: Element | null\n): Parsed<CTA, RecoverableError> => {\n  if (element === null)\n    throw new Error('');\n\n  const anchor = element.querySelector(getSelector(type));\n  if (!anchor)\n    throw new Error('');\n\n  const [{ text, href }, es] = parseLink(anchor);\n  return [\n    {\n      type: type.type,\n      text,\n      href,\n    },\n    es\n  ]\n}\n\nexport const parsePrimaryCTA = parseCTA({ type: \"PrimaryCTA\" });\n\nexport const parseSecondaryCTA = parseCTA({ type: \"SecondaryCTA\" });\n\nexport const parseProductEntryCTA = (\n  element: Element | null\n): Parsed<ProductEntryCTA, RecoverableError> => alternative(parsePrimaryCTA)\n  .or(parseSecondaryCTA)\n  .eval(element);\n\ntype CTA\n  = PrimaryCTA\n  | SecondaryCTA;\n\nconst getSelector = ({ type }: Pick<CTA, 'type'>): string => {\n  switch (type) {\n    case \"PrimaryCTA\": return 'strong > a';\n    case \"SecondaryCTA\": return 'em > a';\n    default: throw new Error('');\n  }\n}\n\n", "import { PrimaryCTA, ProductEntryCTA, SecondaryCTA } from \"./Parse\";\n\nexport const primaryCTA = ({\n  text,\n  href\n}: PrimaryCTA): HTML => `\n<a href=\"${href}\" class=\"feds-primary-cta\">\n  ${text}\n</a>\n`;\n\nexport const secondaryCTA = ({\n  text,\n  href\n}: SecondaryCTA): HTML => `\n<a href=\"${href}\" class=\"feds-secondary-cta\">\n  ${text}\n</a>\n`;\n\nexport const productEntryCTA = (\n  cta: ProductEntryCTA\n): HTML => {\n  if (cta.type === \"PrimaryCTA\")\n    return primaryCTA(cta);\n  return secondaryCTA(cta);\n}\n\n", "import { Link } from \"./Parse\";\n\nexport const link = ({\n  text,\n  href\n}: Link): HTML => `<a href=\"${href}\">${text}</a>`;\n", "import { IrrecoverableError, RecoverableError } from \"../../Error/Error\";\nimport { alternative } from \"../../Utils/Utils\";\nimport { Link, parseLink } from \"../Link/Parse\";\n\nexport type LinkGroupHeader = {\n  type: \"LinkGroupHeader\";\n  title: string;\n  classes: string[];\n};\n\nexport type LinkGroupLink = {\n  type: \"LinkGroupLink\";\n  iconHref: string | null;\n  iconAlt: string | null;\n  title: string;\n  href: string;\n  subtitle: string;\n}\n\nexport type LinkGroupBlue = {\n  type: \"LinkGroupBlue\";\n  link: Link;\n};\n\nexport type LinkGroup\n  = LinkGroupHeader\n  | LinkGroupLink\n  | LinkGroupBlue;\n\n\nexport const parseLinkGroup = (\n  element: Element | null\n): Parsed<LinkGroup, RecoverableError> => \n  alternative(parseLinkGroupHeader)\n    .or(parseLinkGroupLink)\n    .or(parseLinkGroupBlue)\n    .eval(element);\n\n/* example structure of a link group\n*\n* <div class=\"link-group\">\n*   <div>\n*     <div><a href=\"/federal/assets/svgs/creative-cloud-40.svg\">https://main--federal--adobecom.hlx.page/federal/assets/svgs/creative-cloud-40.svg | Adobe Creative Cloud</a></div>\n*     <div>\n*       <p><a href=\"https://www.adobe.com/creativecloud.html\">What is Creative Cloud?</a></p>\n*       <p>Creative apps and services for everyone</p>\n*     </div>\n*   </div>\n* </div>\n*  \n* Sometimes it's slightly different\n* <div class=\"link-group gray-gradient bold header\">\n    <div>\n      <div></div>\n      <div>\n        <h5 id=\"document-productivity\"><a href=\"bookmark://_document-productivity\">Document productivity</a></h5>\n      </div>\n    </div>\n  </div>\n*\n*/\n\nconst ERRORS = {\n  elementNull: \"Element not found\",\n  noTitleAnchor: \"Title anchor not found\",\n  noHref: \"Title Anchor has no href\",\n  noTitle: \"Title text not found\",\n  noSubtitleP: \"Subtitle <p> not found\",\n  noSubtitle: \"Subtitle text not found\",\n  notAHeader: \"Expected a Header class\",\n};\n\nconst parseLinkGroupLink = (\n  element: Element | null\n): Parsed<LinkGroup, RecoverableError> => {\n  const errors = new Set<RecoverableError>();\n  if (!element)\n    throw new IrrecoverableError(ERRORS.elementNull);\n\n  const titleElement = element.querySelector(\"p a\");\n  if (!titleElement)\n    throw new IrrecoverableError(ERRORS.noTitleAnchor);\n\n  const title = titleElement.textContent ?? '';\n  if (title === '')\n    errors.add(new RecoverableError(ERRORS.noTitle));\n\n  const href = titleElement.getAttribute(\"href\") ?? '';\n  if (href === '')\n    errors.add(new RecoverableError(ERRORS.noHref));\n\n  const subtitleElement = titleElement\n    ?.closest(\"p\")\n    ?.nextElementSibling;\n  if (!subtitleElement)\n    throw new IrrecoverableError(ERRORS.noSubtitleP);\n\n  const subtitle = subtitleElement.textContent ?? '';\n  if (subtitle === '')\n    errors.add(new RecoverableError(ERRORS.noSubtitle));\n\n  const [iconHref = null, iconAlt = null] = (element\n    .firstElementChild\n    ?.firstElementChild\n    ?.textContent\n    ?.split(\"|\") ?? []).map(x => x.trim());\n  return [\n    {\n      type: \"LinkGroupLink\",\n      iconHref,\n      iconAlt,\n      title,\n      href,\n      subtitle\n    },\n    [...errors]\n  ]\n}\n\nconst parseLinkGroupHeader = (\n  element: Element | null\n): Parsed<LinkGroup, RecoverableError> => {\n  if (!element)\n    throw new IrrecoverableError(ERRORS.elementNull);\n  \n  const classes = [...element.classList];\n\n  if(!classes.includes('header'))\n    throw new IrrecoverableError(ERRORS.notAHeader);\n\n  const title = element.querySelector('h5')?.textContent ?? \"\";\n  if(title === \"\")\n    throw new IrrecoverableError(ERRORS.noTitle);\n\n  return [\n    {\n      type: \"LinkGroupHeader\",\n      title,\n      classes,\n    },\n    []\n  ];\n};\n\nconst parseLinkGroupBlue = (\n  element: Element | null\n): Parsed<LinkGroup, RecoverableError> => {\n  if (!element)\n    throw new IrrecoverableError(ERRORS.elementNull);\n\n  if (!element.classList.contains('blue'))\n    throw new Error('Not a Blue Link Group');\n\n  const a = element.querySelector('a');\n  const [link, es] = parseLink(a);\n\n  return [\n    {\n      type: \"LinkGroupBlue\",\n      link\n    },\n    es\n  ];\n};\n", "import { IrrecoverableError, RecoverableError } from \"../../Error/Error\";\nimport { alternative, getNextSiblings, parseListAndAccumulateErrors, split, takeWhile } from \"../../Utils/Utils\";\nimport { parsePrimaryCTA, parseSecondaryCTA, PrimaryCTA, SecondaryCTA } from \"../CTA/Parse\";\nimport { Link, parseLink } from \"../Link/Parse\";\nimport { LinkGroup, parseLinkGroup } from \"../LinkGroup/Parse\";\n\nexport type Tab = {\n  type: \"Tab\";\n  title: string | null;\n  CTA: PrimaryCTA | undefined;\n  columns: List<List<ColumnItem>> | MenuPromo;\n};\n\n// We have to return a list of Tabs here because\n// SingleColumnSectionList is essentially a list\n// of tabs. A tab is essentially a Column Section\n// from the old paradigm\nexport const parseTab = (\n  el: Element\n): Parsed<List<Tab>, RecoverableError> => {\n  const [parsedColumn, errors] = parseColumn(el);\n  return ((): Parsed<Tab[], RecoverableError> => {\n    switch (parsedColumn.type) {\n      case \"SingleColumnSection\":\n        return [\n          [{\n            type: \"Tab\",\n            title: parsedColumn.title,\n            columns: [parsedColumn.items],\n            CTA: getTabCTA(parsedColumn),\n          }],\n          errors\n        ];\n      case \"SingleColumnSectionList\":\n        return [\n          parsedColumn.sections.flatMap(section => ({\n            type: \"Tab\",\n            title: section.title,\n            columns: [section.items],\n            CTA: getTabCTA(section),\n          })),\n          errors\n        ]\n      case \"MultiColumnSection\":\n        return [\n          [{\n            type: \"Tab\",\n            title: parsedColumn.title,\n            columns: parsedColumn.columns,\n            CTA: getTabCTA(parsedColumn)\n          }],\n          errors\n        ];\n      case \"MenuPromo\":\n        return [\n          [{\n            type: \"Tab\",\n            title: \"More\", // TODO: Implement Placeholders\n            columns: parsedColumn,\n            CTA: undefined\n          }],\n          errors\n        ];\n      default: parsedColumn satisfies never; return [[], []];\n    }\n  })();\n};\n\nconst getTabCTA = (\n  section: SingleColumnSection | MultiColumnSection\n): PrimaryCTA | undefined => {\n  if (section.type === 'SingleColumnSection') {\n    return section.items\n      .find(item => item.type === 'PrimaryCTA');\n  }\n  return section.columns\n    .flat()\n    .find(item => item.type === 'PrimaryCTA');\n}\n\nexport type Column\n  = SingleColumnSection\n  | SingleColumnSectionList\n  | MultiColumnSection\n  | MenuPromo;\n\ntype ColumnParser = (_: Element)\n  => Parsed<Column, RecoverableError>;\n\nconst parseColumn = (\n  el: Element\n): Parsed<Column, RecoverableError> =>\n  alternative(parseSingleColumnSectionList as ColumnParser)\n    .or(parseSingleColumnSection)\n    .or(parseMultiColumnSection)\n    .or(parseMenuPromo)\n    .eval(el);\n\nexport type ColumnItem\n  = LinkGroup\n  | Link\n  | PrimaryCTA\n  | SecondaryCTA;\n\nconst parseColumnItems = (\n  items: List<Element>\n): Parsed<List<ColumnItem>, RecoverableError> =>\n  parseListAndAccumulateErrors(items, (item) =>\n    alternative(\n      parseLinkGroup as (_: Element) => Parsed<ColumnItem, RecoverableError>)\n      .or(parsePrimaryCTA)\n      .or(parseSecondaryCTA)\n      .or(parseLink)\n      .eval(item)\n  );\n\nconst extractColumnItems = (\n  elements: List<Element>\n): List<Element> =>\n  elements.flatMap(item => {\n    if (item.nodeName === 'UL')\n      return [...item.querySelectorAll('li > a')];\n    return [item];\n  });\n\nexport type SingleColumnSection = {\n  type: \"SingleColumnSection\";\n  title: string | null;\n  items: List<ColumnItem>;\n};\n\nconst parseSingleColumnSection = (\n  element: Element\n): Parsed<SingleColumnSection, RecoverableError> => {\n\n  if (element.querySelector('.gnav-promo')) \n    throw new Error('This is a promo');\n\n  if (element.querySelector('.column-break'))\n    throw new IrrecoverableError(\"Has a column break\");\n\n  const h5 = element.firstElementChild;\n  if (h5 === null)\n    throw new IrrecoverableError(\"No Children\"); // TODO put this into ERRORS\n\n  const title\n    = h5.nodeName === 'H5'\n    ? (h5.textContent ?? null)\n    : null\n  const columnItems\n    = h5.nodeName === 'H5'\n    ? getNextSiblings(h5)\n    : [...element.children];\n  const rawLinks = extractColumnItems(columnItems);\n  const [items, es] = parseColumnItems(rawLinks);\n\n  return [\n    {\n      type: \"SingleColumnSection\",\n      title,\n      items\n    },\n    es\n  ];\n}\n\nexport type SingleColumnSectionList = {\n  type: \"SingleColumnSectionList\";\n  sections: List<SingleColumnSection>;\n};\n\nexport const parseSingleColumnSectionList = (\n  element: Element\n): Parsed<SingleColumnSectionList, RecoverableError> => {\n  if (element.querySelector('.column-break'))\n    throw new IrrecoverableError(\"Has a column break\");\n\n  const h5s = [...element.querySelectorAll('h5')];\n  if (h5s.length <= 1)\n    throw new IrrecoverableError(\"Not a section list\");\n\n  const parseSection = (\n    h5: Element\n  ): Parsed<SingleColumnSection, RecoverableError> => {\n    const container = document.createElement('div');\n    const listItems = \n      takeWhile(\n        (x: Element) =>\n          x.nodeName !== 'H5')(getNextSiblings(h5));\n    container.append(h5, ...listItems);\n    return parseSingleColumnSection(container);\n  };\n  const [sections, es]\n    = parseListAndAccumulateErrors(h5s, parseSection);\n\n  return [\n    {\n      type: \"SingleColumnSectionList\",\n      sections\n    },\n    es\n  ];\n};\n\nexport type MultiColumnSection = {\n  type: \"MultiColumnSection\";\n  title: string;\n  columns: List<List<ColumnItem>>;\n};\n\nconst parseMultiColumnSection = (\n  element: Element\n): Parsed<MultiColumnSection, RecoverableError> => {\n  if (!element.querySelector('.column-break'))\n    throw new IrrecoverableError(\"Expected a Column Break\");\n  const h5 = element.firstElementChild;\n  if (h5 === null || h5.nodeName !== 'H5')\n    throw new IrrecoverableError(ERRORS.expectedH5);\n  const title = h5.textContent;\n  if (title === '' || title === null)\n    throw new IrrecoverableError(ERRORS.emptyTitle);\n\n  const isColumnBreak = (x: Element): boolean =>\n    x.classList.contains('column-break')\n  const rawColumns =\n    split(isColumnBreak)(getNextSiblings(h5))\n      .map(extractColumnItems);\n  const [columns, es] =\n    parseListAndAccumulateErrors(rawColumns, parseColumnItems);\n\n  return [\n    {\n      type: \"MultiColumnSection\",\n      title,\n      columns\n    },\n    es\n  ];\n};\n\nexport type MenuPromo = {\n  type: \"MenuPromo\";\n  content: HTML;\n};\n\nexport const parseMenuPromo = (\n  element: Element | null\n): Parsed<MenuPromo, RecoverableError> => {\n  if (element === null)\n    throw new IrrecoverableError(ERRORS.elementNull);\n  // TODO: Should gnav-image be treated differently?\n  const promo = element.querySelector('.gnav-promo, .gnav-image');\n  if (promo === null)\n    throw new IrrecoverableError(ERRORS.noPromo);\n  const content = promo.innerHTML ?? '';\n  if (content === '')\n    throw new IrrecoverableError(ERRORS.noPromoContent);\n  return [\n    {\n      type: \"MenuPromo\",\n      content\n    },\n    []\n  ]\n};\n\nconst ERRORS = {\n  expectedH5: \"Expected an H5 element for the title \",\n  emptyTitle: \"Expected Title to not be empty\",\n  elementNull: \"Element is null\",\n  noPromo: \"Promo or gnav image not found\",\n  noPromoContent: \"Promo Content not found\",\n};\n", "import { IrrecoverableError, RecoverableError } from \"../../Error/Error\";\nimport { fetchAndProcessPlainHTML, inlineNestedFragments, parseListAndAccumulateErrors } from \"../../Utils/Utils\";\nimport { parseTab } from \"../Tab/Parse\";\nimport { Link, parseLink } from \"../Link/Parse\";\nimport { Tab } from \"../Tab/Parse\";\n\n\nexport type MegaMenu = {\n  type: \"MegaMenu\";\n  title: string;\n  tabs: Promise<Parsed<List<Tab>, RecoverableError>>;\n  crossCloudMenu: List<Link>;\n  isSection: boolean;\n};\n\n\nexport const parseMegaMenu = (\n  element: Element | null\n): Parsed<MegaMenu, RecoverableError> => {\n  const errors = new Set<RecoverableError>();\n  if (element === null)\n    throw new IrrecoverableError(ERRORS.elementNull);\n\n  const title = element.querySelector('h2')?.textContent ?? \"\";\n  if (title === \"\")\n    errors.add(new RecoverableError(ERRORS.noTitle))\n\n  const tabs = (async (): \n                   Promise<Parsed<List<Tab>, RecoverableError>> => {\n    try {\n      const fragment: HTMLAnchorElement | null = element.querySelector('h2 > a');\n      const fragmentURL = new URL(fragment?.href ?? \"\");\n      const initialFragment =\n        await fetchAndProcessPlainHTML(fragmentURL);\n      if (initialFragment instanceof IrrecoverableError)\n        throw new Error(initialFragment.message);\n      const megaMenuFragment = await inlineNestedFragments(initialFragment);\n      if (megaMenuFragment instanceof IrrecoverableError)\n        throw new Error(megaMenuFragment.message);\n      const unparsedTabs = [...megaMenuFragment.children]\n      const [tabs, errors] = parseListAndAccumulateErrors(\n        unparsedTabs,\n        parseTab,\n      );\n      return [tabs.flat(), errors];\n    } catch (e) {\n        // @ts-expect-error errors usually have a message\n        throw new IrrecoverableError(e?.message);\n    }\n  })();\n  const unparsedCrossCloud = element.querySelectorAll(\n    '.cross-cloud-menu ul > li > a'\n  );\n  const [crossCloudMenu, ccmErrors] = parseListAndAccumulateErrors(\n    [...unparsedCrossCloud],\n    parseLink\n  );\n\n  const isSection = element.classList.contains('section');\n\n  return [\n    {\n      type: \"MegaMenu\",\n      title,\n      tabs,\n      crossCloudMenu,\n      isSection\n    },\n    [\n      ...ccmErrors,\n      ...errors\n    ]\n  ]\n};\n\nconst ERRORS = {\n  elementNull: \"Element is null\",\n  noTitle: \"Large Menu has no Title\",\n};\n", "import { MegaMenu } from \"./Parse\";\nimport { sanitize } from \"../../Utils/Utils\";\n\nexport const renderGhostTabs = (title: string): HTML => {\n  const tab = () => ({ name: '', description: ''});\n  const tabs = [0, 1, 2, 3].map(tab);\n  return `\n  <div class=\"feds-popup loading\" aria-hidden=\"true\">\n    <div class=\"top-bar\">\n    </div>\n    <div class=\"title\">\n      <h2>${title}</h2>\n    </div>\n    <div class=\"tabs\" role=\"tablist\">\n      ${tabs.map(({ name, description }, i) => `\n        <div class=\"tab-wrapper\">\n          <button\n          role=\"tab\"\n          class=\"tab\"\n          aria-selected=\"false\"\n          aria-controls=\"${i}\"\n          >${name.trim() === '' ? '<div></div>' : name}</button>\n          ${description ? `<div class=\"feds-menu-description\">${description}</div>` : ''}\n        </div>\n      `).join('')}\n    </div>\n    <div class=\"tab-content\">\n    ${tabs.map((_, i) => `\n        <div\n          id=\"${i}\"\n          role=\"tabpanel\"\n          aria-labelledby=\"${i}\"\n          class=\"feds-navLink-content\"\n        >\n      <div class=\"feds-navLink-title\"></div>\n      <div class=\"feds-navLink-description\"></div>\n      </div>`).join('')}\n  </div>\n  `;\n}\n\n/* \n* We don't render columns immediately\n* So that we can deal with the ghost state\n* and so on.\n*/\n      \nexport const megaMenu = ({\n  title,\n  isSection\n}: MegaMenu): HTML => `\n  <button type=\"button\"\n          aria-expanded=\"false\"\n          aria-controls=\"${sanitize(title)}\"\n          class=\"mega-menu\"\n  >\n    ${title}\n  </button>\n  <div id=\"${sanitize(title)}\" class=\"feds-popup${isSection ? '' : ' section'}\">\n    <ul>\n      \n    </ul>\n  </div>\n`\n", "import { IrrecoverableError, RecoverableError } from \"../../Error/Error\";\nimport { alternative, getNextSiblings, parseListAndAccumulateErrors } from \"../../Utils/Utils\";\nimport { MenuPromo, parseMenuPromo, parseSingleColumnSectionList, SingleColumnSectionList } from \"../Tab/Parse\";\nimport { Link, parseLink } from \"../Link/Parse\";\n\nexport type SmallMenu = {\n  type: \"SmallMenu\";\n  title: string;\n  columns: SingleColumnSectionList | List<List<Link>>;\n  promo: MenuPromo | null;\n};\n\ntype ColumnParser = (\n  _: Element\n) => Parsed<SingleColumnSectionList | List<List<Link>>, RecoverableError>;\n\nexport const parseSmallMenu = (\n  element: Element | null\n): Parsed<SmallMenu, RecoverableError> => {\n  const errors = [];\n  if (element === null)\n    throw new IrrecoverableError(ERRORS.elementNull);\n\n  const h2 = element.querySelector('h2')\n  const title = h2?.textContent ?? \"\";\n  if (title === \"\")\n    errors.push(new RecoverableError(ERRORS.noTitle))\n\n  const columnsContainer = ((): Element => {\n    if (h2 === null)\n      return element;\n    const container = document.createElement('div');\n    getNextSiblings(h2).forEach(s => container.appendChild(s));\n    return container;\n  })();\n  const [columns, es]\n    = alternative(parseSingleColumnSectionList as ColumnParser)\n    .or((el) => parseListAndAccumulateErrors(\n      [...el.children],\n      parseNoTitleColumn\n    )).eval(columnsContainer);\n  \n  const [promo, pes] = ((): Parsed<MenuPromo | null, RecoverableError> => {\n    try {\n      return parseMenuPromo(element);\n    } catch (_) {\n      return [null, []];\n    }\n  })();\n\n  return [\n    {\n      type: \"SmallMenu\",\n      title,\n      columns,\n      promo\n    },\n    [\n      ...es,\n      ...pes\n    ]\n  ];\n};\n\nconst parseNoTitleColumn = (\n  element: Element\n): Parsed<List<Link>, RecoverableError> => {\n  if (element.nodeName !== 'UL')\n    throw new Error('');\n  const links = [...element.querySelectorAll('ul > li > a')];\n  return parseListAndAccumulateErrors(links, parseLink);\n};\n\nconst ERRORS = {\n  elementNull: \"The element to be parsed is null\",\n  noTitle: \"Small menu has no title\",\n}\n", "import { LinkGroup, LinkGroupBlue, LinkGroupHeader, LinkGroupLink } from \"./Parse\";\n\nexport const linkGroup = (lg: LinkGroup): HTML => {\n  switch (lg.type) {\n    case \"LinkGroupHeader\": return linkGroupHeader(lg);\n    case \"LinkGroupLink\": return linkGroupLink(lg);\n    case \"LinkGroupBlue\": return linkGroupBlue(lg);\n    default: {\n      const exhaustivenessCheck: never = lg;\n      console.error(exhaustivenessCheck);\n      return \"\";\n    }\n  }\n};\n\nconst linkGroupHeader = ({\n  title,\n  classes\n}: LinkGroupHeader): HTML => `\n  <div role=\"heading\" class=\"${classes.join(',')}\">\n    <div class=\"title\">${title}</div>\n  </div>\n`;\n\nconst linkGroupLink = ({\n  iconHref,\n  iconAlt,\n  title,\n  href,\n  subtitle\n}: LinkGroupLink): HTML => {\n  const hasIcon = iconAlt !== null && iconHref !== null;\n  const icon = !hasIcon\n    ? \"\"\n    : `\n      <picture>\n        <img\n          loading=\"lazy\"\n          src=\"${iconHref}\"\n          alt=\"${iconAlt}\"\n        >\n      </picture>\n    `;\n  return `\n    <a class=\"link-group\" href=\"${href}\">\n      ${icon}\n      <div class=\"content\">\n        <div class=\"title\">${title}</div>\n        <div class=\"subtile\">${subtitle}</div>\n      </div>\n    </a>\n  `\n}\n\nconst linkGroupBlue = ({\n  link\n}: LinkGroupBlue): HTML => `\n  <a href=\"${link.href}\" class=\"link-group blue\">\n    ${link.text}\n  </a>\n`;\n\n", "import { ColumnItem, MenuPromo, Tab } from \"./Parse\";\nimport { linkGroup } from \"../LinkGroup/Render\";\nimport { link } from \"../Link/Render\";\nimport { primaryCTA, secondaryCTA } from \"../CTA/Render\";\nimport { renderListItems } from \"../../Utils/Utils\";\n\nexport const tabs = (\n  ts: List<Tab>,\n): HTML => `\n  <div class=\"tabs\" role=\"tablist\">\n    ${ts.map((t, i) => `\n      <button\n        role=\"tab\"\n        class=\"tab\"\n        aria-selected=\"false\"\n        aria-controls=\"${i}\"\n      >\n        ${t.title === '' ? '<div></div>' : t.title}\n      </button>\n    `).join('')}\n  </div>\n  <div class=\"tab-content\">\n    ${ts.map((t, i) => {\n      return `\n      <div\n        id=\"${i}\"\n        role=\"tabpanel\"\n        class=\"${Array.isArray(t.columns) &&\n          t.columns\n           .flat()\n           .some(item => item.type === \"LinkGroupHeader\")\n          ? \"has-subheader\"\n          : \"\"\n        }\"\n        hidden\n      >\n        <ul>\n        ${Array.isArray(t.columns)\n          ? renderListItems(t.columns, links => `\n                              <ul>\n                                ${renderListItems(\n                                  links.filter(l => \n                                      l.type !== 'PrimaryCTA'),\n                                  columnItem\n                                )}\n                              </ul>\n                            `)\n          : t.columns.content}\n        </ul>\n        <div class=\"sticky-cta\">\n          ${t.CTA ? columnItem(t.CTA) : ''}\n        </div>\n      </div>\n    `.trim();\n    }).join('')\n  }\n  </div>\n`.trim();\n\nexport const menuPromo = ({\n  content\n}: MenuPromo): HTML => content\n\nexport const columnItem = (\n  item: ColumnItem\n): HTML => {\n  switch (item.type) {\n    case \"LinkGroupHeader\":\n    case \"LinkGroupLink\":\n    case \"LinkGroupBlue\":\n      return linkGroup(item);\n    case \"Link\":\n      return link(item);\n    case \"PrimaryCTA\":\n      return primaryCTA(item);\n    case \"SecondaryCTA\":\n      return secondaryCTA(item);\n    default: {\n      item satisfies never;\n      return \"\";\n    }\n  }\n}\n", "import { renderListItems, sanitize } from \"../../Utils/Utils\";\nimport { SingleColumnSectionList } from \"../Tab/Parse\";\nimport { columnItem, menuPromo } from \"../Tab/Render\";\nimport { Link } from \"../Link/Parse\";\nimport { link } from \"../Link/Render\";\nimport { SmallMenu } from \"./Parse\";\n\nexport const smallMenu = ({\n  title,\n  columns,\n  promo\n}: SmallMenu): HTML => `\n  <button type=\"button\"\n          aria-expanded=\"false\"\n          aria-controls=\"${sanitize(title)}\"\n  >\n    ${title}\n  </button>\n  <div class=\"feds-popup\" id=\"${sanitize(title)}\">\n    ${smallMenuList(columns)}\n    ${promo === null ? '' : `<li>${menuPromo(promo)}</li>`}\n  </div>\n`;\n\nconst smallMenuList = (\n  c: SingleColumnSectionList | List<List<Link>>\n): HTML => {\n  if (!Array.isArray(c) && c?.type === \"SingleColumnSectionList\")\n    return column(c);\n  return `\n  <ul>\n    ${renderListItems(c as List<List<Link>>, (l) => `\n      <ul>\n        ${renderListItems(l, link)}\n      </ul>\n    `)}\n  </ul>\n  `;\n}\n\nconst column = (\n  c: SingleColumnSectionList\n): HTML => `\n  <ul>\n    ${renderListItems(c.sections, (section): string => `\n      <ul>\n        ${section.title === null\n          ? ''\n          : `<span class=\"column-section-title\">${section.title}</span>`\n        }\n        ${renderListItems(section.items, columnItem)}\n      </ul>\n    `.trim())}\n  </ul>\n`.trim();\n", "import { RecoverableError } from \"../../Error/Error\";\n\nexport type Text = {\n  type: \"Text\";\n  content: string;\n};\n\nconst ERRORS = {\n  elementNull: \"Error when parsing text. Element is null\",\n  textContentNull: \"Error when parsing text. Element has no textContent\",\n}\n\nexport const parseText = (\n  element: Element | null\n): Parsed<Text, RecoverableError> => {\n  if (element === null)\n    return [\n      {\n        type: \"Text\" ,\n        content: \"\"\n      },\n      [new RecoverableError(ERRORS.elementNull, \"Minor\")]\n    ];      \n  const content = element.textContent;\n  if (content === null)\n    return [\n      {\n        type: \"Text\",\n        content: \"\",\n      },\n      [new RecoverableError(ERRORS.textContentNull, \"Minor\")]\n    ];\n  return [\n    {\n      type: \"Text\",\n      content,\n    },\n    []\n  ]\n};\n\n", "import { Text } from \"./Parse\";\n\nexport const text = ({ content }: Text): HTML => content;\n", "import { IrrecoverableError, RecoverableError } from \"../Error/Error\";\nimport { Brand, parseBrand } from \"./Brand/Parse\";\nimport { brand } from \"./Brand/Render\";\nimport { parsePrimaryCTA, parseSecondaryCTA, PrimaryCTA, SecondaryCTA } from \"./CTA/Parse\";\nimport { primaryCTA, secondaryCTA } from \"./CTA/Render\";\nimport { Link, parseLink } from \"./Link/Parse\";\nimport { link } from \"./Link/Render\";\nimport { MegaMenu, parseMegaMenu } from \"./MegaMenu/Parse\";\nimport { megaMenu } from \"./MegaMenu/Render\";\nimport { parseSmallMenu, SmallMenu } from \"./SmallMenu/Parse\";\nimport { smallMenu } from \"./SmallMenu/Render\";\nimport { parseText, Text } from \"./Text/Parse\";\nimport { text } from \"./Text/Render\";\n\nexport type Component\n  = Text\n  | Link\n  | SecondaryCTA\n  | PrimaryCTA\n  | Brand\n  | SmallMenu\n  | MegaMenu;\n\nexport const parseComponent = (\n  element: Element\n): Parsed<Component, RecoverableError> => {\n  if (element === null)\n    throw new IrrecoverableError(ERRORS.elementNull);\n\n  const brandElem = element.querySelector('.gnav-brand');\n  if (brandElem !== null) \n    return parseBrand(element)\n\n  const largeMenu = element.querySelector('.large-menu');\n  if (largeMenu !== null)\n    return parseMegaMenu(largeMenu);\n\n  if (element.querySelector('h5, ul, link-group') !== null)\n    return parseSmallMenu(element);\n\n  if (element.querySelector('strong') !== null)\n    return parsePrimaryCTA(element);\n  \n  if (element.querySelector('em') !== null)\n    return parseSecondaryCTA(element);\n\n  if (element.querySelector('a') === null)\n    return parseText(element);\n\n  return parseLink(element.querySelector('a'));\n};\n\nexport const component = (\n  c: Component\n): HTML => {\n  switch (c.type) {\n    case \"Text\": return text(c);\n    case \"Link\": return link(c);\n    case \"SecondaryCTA\": return secondaryCTA(c);\n    case \"PrimaryCTA\": return primaryCTA(c);\n    case \"Brand\": return brand(c);\n    case \"SmallMenu\": return smallMenu(c);\n    case \"MegaMenu\": return megaMenu(c);\n    default: {\n      const exhaustive : never = c;\n      console.error(`Failed to recognize component: ${exhaustive}`);\n      return '';\n    }\n  }\n};\n\nconst ERRORS = {\n  elementNull: \"Element is null\",\n};\n\n", "import { Component, parseComponent } from \"../Components/Component\";\nimport { parseProductEntryCTA, ProductEntryCTA } from \"../Components/CTA/Parse\";\nimport { Link, parseLink } from \"../Components/Link/Parse\";\nimport { IrrecoverableError, RecoverableError } from \"../Error/Error\";\nimport { parseListAndAccumulateErrors } from \"../Utils/Utils\";\n\nexport type GlobalNavigationData = {\n  breadcrumbs: List<Link>;\n  components: List<Component>;\n  productCTA: ProductEntryCTA | null;\n  localnav: boolean;\n  errors: List<RecoverableError>;\n};\n\nexport const parseNavigation = (\n  mainNav: HTMLElement\n): GlobalNavigationData | IrrecoverableError => {\n  const [breadcrumbs, breadcrumbErrors]\n    = parseListAndAccumulateErrors(\n      [...document.querySelectorAll('.breadcrumbs ul > li > a') ?? []],\n      parseLink\n    );\n  const [components, componentErrors] \n    = parseListAndAccumulateErrors(\n      [...mainNav.children],\n      parseComponent\n    ); \n  const productEntryElement = mainNav.querySelector('.product-entry-cta');\n  const [productCTA, productCtaErrors]\n    = (\n  (): Parsed<ProductEntryCTA | null, RecoverableError> => {\n    try {\n      return parseProductEntryCTA(productEntryElement);\n    } catch (_) {\n      return [null, []];\n    }\n  })();\n  const localnav = components\n    .filter((component): boolean =>\n            component.type === \"MegaMenu\" &&\n            component.isSection).length === 1;\n  const errors = [\n    breadcrumbErrors,\n    componentErrors,\n    productCtaErrors,\n  ].flat();\n\n  return {\n    breadcrumbs,\n    components,\n    productCTA,\n    localnav,\n    errors,\n  }\n};\n", "import { setupMobileDesktopListeners, zip } from \"../Utils/Utils\";\n\ntype CleanupFunction = () => void\n\nconst mobileClickListeners = (\n  gnav: HTMLElement\n): CleanupFunction => {\n  const tabButtons = [...gnav.querySelectorAll('.tabs > button[role=\"tab\"]')];\n  const tabPanels = [...gnav.querySelectorAll('.tab-content > div')];\n  const tabButtonClickCallbacks = tabButtons.map((button, i) => (): void => {\n      tabButtons.forEach(tabButton => {\n        tabButton.setAttribute('aria-selected', 'false');\n      });\n      tabPanels.forEach(tabPanel => {\n        tabPanel.setAttribute('hidden', 'true');\n      });\n      tabPanels[i]?.removeAttribute('hidden');\n      button.setAttribute('aria-selected', 'true');\n    }\n  );\n  tabButtons.forEach((button, i) => {\n    button.addEventListener('click', tabButtonClickCallbacks[i]);\n  });\n  return () => {\n    tabButtons.forEach((button, i) => {\n      button.removeEventListener('click', tabButtonClickCallbacks[i]);\n    });\n  };\n};\n\nconst desktopClickListeners = (\n  gnav: HTMLElement\n): CleanupFunction => {\n  return () => console.log(gnav);\n};\n\nexport const initClickListeners = mobileClickListeners\n\n", "import { setupMobileDesktopListeners } from \"../Utils/Utils\";\n\ntype CleanupFunction = () => void\n\nconst initDesktopKeyboardNav = (\n  gnav: HTMLElement\n): CleanupFunction => {\n  return () => console.log(gnav);\n};\n\nconst initMobileKeyboardNav = (\n  gnav: HTMLElement\n): CleanupFunction => {\n  return () => console.log(gnav);\n};\n\nexport const initKeyboardNav =  setupMobileDesktopListeners({\n  mobileEventListeners: initMobileKeyboardNav,\n  desktopEventListeners: initDesktopKeyboardNav,\n});\n", "import { IrrecoverableError } from \"../Error/Error\";\nimport { Input } from \"../Main\";\nimport { fetchAndProcessPlainHTML } from \"../Utils/Utils\";\n\ntype Initial = {\n  mainNav: HTMLElement;\n  aside: HTMLElement | IrrecoverableError;\n};\n\nexport const getInitialHTML = async ({\n  gnavSource,\n  asideSource\n}: Input): Promise<Initial | IrrecoverableError> => {\n  const mainNav = await fetchAndProcessPlainHTML(gnavSource);\n  if (mainNav instanceof IrrecoverableError)\n    return mainNav;\n  const aside = await fetchAndProcessPlainHTML(asideSource);\n  return {\n    mainNav,\n    aside,\n  }\n}\n\n", "\n        const css = \"/**\\n * Global Navigation Styles\\n * Styles for the federal global navigation component\\n */\\n\\n/* ========================================\\n   Header Container\\n   ======================================== */\\n\\nheader.global-navigation.site-pivot {\\n    display: block;\\n    visibility: visible;\\n}\\n\\nheader.global-navigation.site-pivot ul {\\n    list-style: none;\\n}\\n\";\n        const style = document.createElement('style');\n        style.textContent = css;\n        document.head.appendChild(style);\n      ", "import { component } from \"./Components/Component\";\nimport { productEntryCTA } from \"./Components/CTA/Render\";\nimport { renderGhostTabs} from \"./Components/MegaMenu/Render\";\nimport { IrrecoverableError, RecoverableError } from \"./Error/Error\";\nimport { GlobalNavigationData, parseNavigation } from \"./Parse/Parse\";\nimport { initClickListeners } from \"./PostRendering/ClickListeners\";\nimport { initKeyboardNav } from \"./PostRendering/Keyboard\";\nimport { UnavConfig } from \"./PostRendering/Unav\";\nimport { getInitialHTML } from \"./PreRendering/FetchAssets\";\nimport { renderListItems } from \"./Utils/Utils\";\nimport './styles/styles.css';\nimport { tabs } from \"./Components/Tab/Render\";\n\n// TODO implement Analytics\n\ntype GlobalNavigation = {\n  closeEverything: () => void;\n  reloadUnav: () => void;\n  getGnavTopPosition: () => number;\n  setGnavTopPosition: (_: number) => void;\n  errors: Set<RecoverableError>;\n};\n\nexport type Input = {\n  gnavSource: URL;\n  asideSource: URL | null;\n  gnavTop?: number;\n  isLocalNav: boolean;\n  mountpoint: HTMLElement;\n  unavEnabled: boolean;\n\n  getStageDomainMap: (domainmap: unknown[], env: string) =>\n    { [key: string]: string }\n  // MEP: {\n  //   commands: unknown;\n  //   handleCommands: (_: unknown) => unknown;\n  // }\n};\n\nexport const main = async (\n  input: Input\n): Promise<GlobalNavigation | IrrecoverableError> => {\n  if (!(input.gnavSource instanceof URL)) {\n    throw new IrrecoverableError(\"gnavSource needs to be a URL object\");\n  }\n  const initial = await getInitialHTML(input)\n  if (initial instanceof IrrecoverableError)\n    throw initial;\n  const { mainNav, aside: _aside } = initial;\n  if (mainNav instanceof IrrecoverableError)\n    throw mainNav;\n\n  const gnavData = parseNavigation(mainNav);\n  if (gnavData instanceof IrrecoverableError)\n    throw gnavData;\n  \n  // TODO: Implement Aside\n  \n  await renderGnav(gnavData)(input.mountpoint);\n\n  return postRenderingTasks(input);\n};\n\n\nexport const renderGnav = (\n  data: GlobalNavigationData\n) => async (\nmountpoint: HTMLElement\n): Promise<HTMLElement> => {\n  const navHTML = renderGnavString(data)\n  mountpoint.innerHTML = navHTML;\n  mountpoint.classList.add('site-pivot');\n  const megaMenus = [\n    ...mountpoint.querySelectorAll('.mega-menu ~ .feds-popup > ul')\n  ]\n  megaMenus.forEach(mm => {\n    mm.innerHTML = renderGhostTabs(mm.textContent?.trim() ?? '');\n  });\n  const mmPromises = data.components\n    .filter(com => com.type === \"MegaMenu\")\n    .map(com => com.tabs);\n  const _errors_ = await Promise.all(mmPromises.map(async (mmPromise, idx) => {\n    const [parsedTabs, errors] = await mmPromise;\n    const renderedTabs = tabs(parsedTabs);\n    megaMenus[idx].innerHTML = renderedTabs;\n    return errors;\n  }).flat());\n  return mountpoint;\n};\n\nexport const renderGnavString = ({\n  components,\n  productCTA,\n}: GlobalNavigationData\n): string => `\n<nav>\n  <ul>\n    ${renderListItems(components, component)}\n  </ul>\n  ${productCTA === null ? '' : productEntryCTA(productCTA)}\n  <div class=\"feds-utilities\">\n  </div>\n</nav>\n`;\n\n\nexport const postRenderingTasks = (\n  input: Input,\n): GlobalNavigation | IrrecoverableError => {\n  const errors = new Set<RecoverableError>();\n  const unav = loadUnav(input.mountpoint);\n  if (unav instanceof RecoverableError)\n    errors.add(unav);\n  else \n    unav.errors.forEach(errors.add);\n  initClickListeners(input.mountpoint);\n  initKeyboardNav(input.mountpoint);\n  \n  const reloadUnav\n    = unav instanceof RecoverableError\n    ? (): void => {}\n    : unav.reloadUnav;\n  return {\n    closeEverything,\n    reloadUnav,\n    errors,\n    setGnavTopPosition: (_): void => {},\n    getGnavTopPosition: (): number => 0\n  };\n};\n\ntype Unav = {\n  reloadUnav: (_?: UnavConfig) => void;\n  errors: Set<RecoverableError>;\n};\n\nconst loadUnav = (\n  _nav: HTMLElement,\n  _config?: UnavConfig\n): Unav | RecoverableError => {\n  return new RecoverableError(\"loadUnav has not been implemented yet\");\n};\n\nconst closeEverything = (): void => {\n};\n"],
  "mappings": "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",
  "names": ["IrrecoverableError", "_IrrecoverableError", "message", "RecoverableError", "_RecoverableError", "severity", "isDesktop", "icons", "split", "predicate", "arr", "splitArrays", "currSubArray", "i", "takeWhile", "predicate", "arr", "firstItem", "remainingItems", "getNextSiblings", "element", "accumulator", "iterator", "alternative", "primaryFn", "fallbackFn", "input", "parseListAndAccumulateErrors", "elements", "parse", "accElems", "accErrors", "parsedElement", "parseErrors", "error", "IrrecoverableError", "setupMobileDesktopListeners", "mobileEventListeners", "desktopEventListeners", "gnav", "cleanup", "isDesktop", "fetchAndProcessPlainHTML", "source", "modifiedSource", "federateUrl", "response", "htmlText", "body", "federatedContentRoot", "getFederatedContentRoot", "cdnWhitelistedOrigins", "origin", "originNoStage", "SLD", "url", "pathname", "search", "hash", "e", "inlineNestedFragments", "processElement", "currentElem", "visitedUrls", "inlineLinks", "anchorElement", "federatedUrl", "fragmentUrl", "fragmentBody", "parentDiv", "renderListItems", "items", "renderFn", "item", "sanitize", "str", "isDarkMode", "ERRORS", "IMG_REGEX", "extractImageSource", "element", "imgSrc", "text", "source", "href", "extractAltText", "alt", "parseBrand", "IrrecoverableError", "rawBlock", "blockLinks", "primaryLink", "link", "textContent", "isBrandImageOnly", "noLogo", "imageOnly", "renderImage", "renderLabel", "imageLinks", "imgSrcDark", "altText", "defaultImgSrc", "icons", "svgImgSrc", "svgDarkImgSrc", "img", "src", "label", "selectSource", "light", "dark", "hasDark", "isDarkMode", "imageData", "css", "style", "renderImage", "image", "imageOnly", "cls", "alt", "renderBrand", "href", "content", "ariaLabel", "brand", "brandData", "data", "aria", "ERRORS", "parseLink", "anchor", "IrrecoverableError", "text", "href", "parseCTA", "type", "element", "anchor", "getSelector", "text", "href", "es", "parseLink", "parsePrimaryCTA", "parseSecondaryCTA", "parseProductEntryCTA", "alternative", "primaryCTA", "text", "href", "secondaryCTA", "productEntryCTA", "cta", "link", "text", "href", "parseLinkGroup", "element", "alternative", "parseLinkGroupHeader", "parseLinkGroupLink", "parseLinkGroupBlue", "ERRORS", "errors", "IrrecoverableError", "titleElement", "title", "RecoverableError", "href", "subtitleElement", "subtitle", "iconHref", "iconAlt", "x", "classes", "a", "link", "es", "parseLink", "parseTab", "el", "parsedColumn", "errors", "parseColumn", "getTabCTA", "section", "item", "alternative", "parseSingleColumnSectionList", "parseSingleColumnSection", "parseMultiColumnSection", "parseMenuPromo", "parseColumnItems", "items", "parseListAndAccumulateErrors", "parseLinkGroup", "parsePrimaryCTA", "parseSecondaryCTA", "parseLink", "extractColumnItems", "elements", "element", "IrrecoverableError", "h5", "title", "columnItems", "getNextSiblings", "rawLinks", "es", "h5s", "parseSection", "container", "listItems", "takeWhile", "x", "sections", "ERRORS", "rawColumns", "split", "columns", "promo", "content", "parseMegaMenu", "element", "errors", "IrrecoverableError", "ERRORS", "title", "RecoverableError", "tabs", "fragment", "fragmentURL", "initialFragment", "fetchAndProcessPlainHTML", "megaMenuFragment", "inlineNestedFragments", "unparsedTabs", "parseListAndAccumulateErrors", "parseTab", "e", "unparsedCrossCloud", "crossCloudMenu", "ccmErrors", "parseLink", "isSection", "renderGhostTabs", "title", "tab", "tabs", "name", "description", "i", "_", "megaMenu", "isSection", "sanitize", "parseSmallMenu", "element", "errors", "IrrecoverableError", "ERRORS", "h2", "title", "RecoverableError", "columnsContainer", "container", "getNextSiblings", "s", "columns", "es", "alternative", "parseSingleColumnSectionList", "el", "parseListAndAccumulateErrors", "parseNoTitleColumn", "promo", "pes", "parseMenuPromo", "links", "parseLink", "linkGroup", "lg", "linkGroupHeader", "linkGroupLink", "linkGroupBlue", "title", "classes", "iconHref", "iconAlt", "href", "subtitle", "icon", "link", "tabs", "ts", "i", "item", "renderListItems", "links", "l", "columnItem", "menuPromo", "content", "linkGroup", "link", "primaryCTA", "secondaryCTA", "smallMenu", "title", "columns", "promo", "sanitize", "smallMenuList", "menuPromo", "c", "column", "renderListItems", "l", "link", "section", "columnItem", "ERRORS", "parseText", "element", "RecoverableError", "content", "text", "content", "parseComponent", "element", "IrrecoverableError", "ERRORS", "parseBrand", "largeMenu", "parseMegaMenu", "parseSmallMenu", "parsePrimaryCTA", "parseSecondaryCTA", "parseText", "parseLink", "component", "c", "text", "link", "secondaryCTA", "primaryCTA", "brand", "smallMenu", "megaMenu", "parseNavigation", "mainNav", "breadcrumbs", "breadcrumbErrors", "parseListAndAccumulateErrors", "parseLink", "components", "componentErrors", "parseComponent", "productEntryElement", "productCTA", "productCtaErrors", "parseProductEntryCTA", "localnav", "component", "errors", "mobileClickListeners", "gnav", "tabButtons", "tabPanels", "tabButtonClickCallbacks", "button", "i", "tabButton", "tabPanel", "initClickListeners", "mobileClickListeners", "initDesktopKeyboardNav", "gnav", "initMobileKeyboardNav", "initKeyboardNav", "setupMobileDesktopListeners", "getInitialHTML", "gnavSource", "asideSource", "mainNav", "fetchAndProcessPlainHTML", "IrrecoverableError", "aside", "css", "style", "main", "input", "IrrecoverableError", "initial", "getInitialHTML", "mainNav", "_aside", "gnavData", "parseNavigation", "renderGnav", "postRenderingTasks", "data", "mountpoint", "navHTML", "renderGnavString", "megaMenus", "mm", "renderGhostTabs", "mmPromises", "com", "_errors_", "mmPromise", "idx", "parsedTabs", "errors", "renderedTabs", "tabs", "components", "productCTA", "renderListItems", "component", "productEntryCTA", "unav", "loadUnav", "RecoverableError", "initClickListeners", "initKeyboardNav", "reloadUnav", "closeEverything", "_", "_nav", "_config"]
}
