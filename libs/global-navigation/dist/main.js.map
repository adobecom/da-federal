{
  "version": 3,
  "sources": ["../src/Components/LinkGroup/Render.ts", "../src/Components/Link/Render.ts", "../src/Components/CTA/Render.ts", "../src/Error/Error.ts", "../src/Utils/Utils.ts", "../src/Components/Column/Render.ts", "../src/Components/Brand/Parse.ts", "../src/Components/Brand/Render.ts", "../src/Components/Link/Parse.ts", "../src/Components/CTA/Parse.ts", "../src/Components/LinkGroup/Parse.ts", "../src/Components/Column/Parse.ts", "../src/Components/MegaMenu/Parse.ts", "../src/Components/MegaMenu/Render.ts", "../src/Components/SmallMenu/Parse.ts", "../src/Components/SmallMenu/Render.ts", "../src/Components/Text/Parse.ts", "../src/Components/Text/Render.ts", "../src/Components/Component.ts", "../src/Parse/Parse.ts", "../src/PostRendering/ClickListeners.ts", "../src/PostRendering/Keyboard.ts", "../src/PreRendering/FetchAssets.ts", "../src/Main.ts"],
  "sourcesContent": ["import { LinkGroup, LinkGroupBlue, LinkGroupHeader, LinkGroupLink } from \"./Parse\";\n\nexport const linkGroup = (lg: LinkGroup): HTML => {\n  switch (lg.type) {\n    case \"LinkGroupHeader\": return linkGroupHeader(lg);\n    case \"LinkGroupLink\": return linkGroupLink(lg);\n    case \"LinkGroupBlue\": return linkGroupBlue(lg);\n    default: {\n      const exhaustivenessCheck: never = lg;\n      console.error(exhaustivenessCheck);\n      return \"\";\n    }\n  }\n};\n\nconst linkGroupHeader = ({\n  title,\n  classes\n}: LinkGroupHeader): HTML => `\n  <div role=\"heading\" class=\"${classes.join(',')}\">\n    <div class=\"title\">${title}</div>\n  </div>\n`;\n\nconst linkGroupLink = ({\n  iconHref,\n  iconAlt,\n  title,\n  href,\n  subtitle\n}: LinkGroupLink): HTML => {\n  const hasIcon = iconAlt !== null && iconHref !== null;\n  const icon = !hasIcon\n    ? \"\"\n    : `\n      <picture>\n        <img\n          loading=\"lazy\"\n          src=\"${iconHref}\"\n          alt=\"${iconAlt}\"\n        >\n      </picture>\n    `;\n  return `\n    <a class=\"link-group\" href=\"${href}\">\n      ${icon}\n      <div class=\"content\">\n        <div class=\"title\">${title}</div>\n        <div class=\"subtile\">${subtitle}</div>\n      </div>\n    </a>\n  `\n}\n\nconst linkGroupBlue = ({\n  link\n}: LinkGroupBlue): HTML => `\n  <a href=\"${link.href}\" class=\"link-group blue\">\n    ${link.text}\n  </a>\n`;\n\n", "import { Link } from \"./Parse\";\n\nexport const link = ({\n  text,\n  href\n}: Link): HTML => `<a href=\"${href}\">${text}</a>`;\n", "import { PrimaryCTA, ProductEntryCTA, SecondaryCTA } from \"./Parse\";\n\nexport const primaryCTA = ({\n  text,\n  href\n}: PrimaryCTA): HTML => `\n<a href=\"${href}\" class=\"feds-primary-cta\">\n  ${text}\n</a>\n`;\n\nexport const secondaryCTA = ({\n  text,\n  href\n}: SecondaryCTA): HTML => `\n<a href=\"${href}\" class=\"feds-secondary-cta\">\n  ${text}\n</a>\n`;\n\nexport const productEntryCTA = (\n  cta: ProductEntryCTA\n): HTML => {\n  if (cta.type === \"PrimaryCTA\")\n    return primaryCTA(cta);\n  return secondaryCTA(cta);\n}\n\n", "export class IrrecoverableError extends Error {\n  constructor(message: string) {\n    super(message);\n    // This is important for proper instanceof checks\n    Object.setPrototypeOf(this, IrrecoverableError.prototype);\n    // TODO: Lana logging logic can go here\n  }\n}\n\ntype Severity\n  = \"Minor\"\n  | \"Major\"\n  | \"Critical\"\n\nexport class RecoverableError extends Error {\n  constructor(message: string, severity: Severity = \"Minor\") {\n    super(message);\n    // This is important for proper instanceof checks\n    Object.setPrototypeOf(this, RecoverableError.prototype);\n    if (severity !== \"Minor\") {\n      // TODO: Lana logging logic can go here\n    }\n  }\n}\n", "import { IrrecoverableError } from \"../Error/Error\";\n\nexport const isDesktop = window.matchMedia('(min-width: 900px)');\n\nexport const icons = {\n  brand: '<svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" id=\"Layer_1\" viewBox=\"0 0 64.57 35\"><defs><style>.cls-1{fill: #eb1000;}</style></defs><path class=\"cls-1\" d=\"M6.27,10.22h4.39l6.2,14.94h-4.64l-3.92-9.92-2.59,6.51h3.08l1.23,3.41H0l6.27-14.94ZM22.03,13.32c.45,0,.94.04,1.43.16v-3.7h3.88v14.72c-.89.4-2.81.89-4.73.89-3.48,0-6.47-1.98-6.47-5.93s2.88-6.13,5.89-6.13ZM22.52,22.19c.36,0,.65-.07.94-.16v-5.42c-.29-.11-.58-.16-.96-.16-1.27,0-2.45.94-2.45,2.92s1.2,2.81,2.47,2.81ZM34.25,13.32c3.23,0,5.98,2.18,5.98,6.02s-2.74,6.02-5.98,6.02-6-2.18-6-6.02,2.72-6.02,6-6.02ZM34.25,22.13c1.11,0,2.14-.89,2.14-2.79s-1.03-2.79-2.14-2.79-2.12.89-2.12,2.79.96,2.79,2.12,2.79ZM41.16,9.78h3.9v3.7c.47-.09.96-.16,1.45-.16,3.03,0,5.84,1.98,5.84,5.86,0,4.1-2.99,6.18-6.53,6.18-1.52,0-3.46-.31-4.66-.87v-14.72ZM45.91,22.17c1.34,0,2.56-.96,2.56-2.94,0-1.85-1.2-2.72-2.5-2.72-.36,0-.65.04-.91.16v5.35c.22.09.51.16.85.16ZM58.97,13.32c2.92,0,5.6,1.87,5.6,5.64,0,.51-.02,1-.09,1.49h-7.27c.4,1.32,1.56,1.94,3.01,1.94,1.18,0,2.27-.29,3.5-.82v2.97c-1.14.58-2.5.82-3.9.82-3.7,0-6.58-2.23-6.58-6.02s2.61-6.02,5.73-6.02ZM60.93,18.02c-.2-1.27-1.05-1.78-1.92-1.78s-1.58.54-1.87,1.78h3.79Z\"/></svg>',\n  company: '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"22\" viewBox=\"0 0 24 22\" fill=\"none\"><path d=\"M14.2353 21.6209L12.4925 16.7699H8.11657L11.7945 7.51237L17.3741 21.6209H24L15.1548 0.379395H8.90929L0 21.6209H14.2353Z\" fill=\"#EB1000\"/></svg>',\n  search: '<svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" focusable=\"false\"><path d=\"M14 2A8 8 0 0 0 7.4 14.5L2.4 19.4a1.5 1.5 0 0 0 2.1 2.1L9.5 16.6A8 8 0 1 0 14 2Zm0 14.1A6.1 6.1 0 1 1 20.1 10 6.1 6.1 0 0 1 14 16.1Z\"></path></svg>',\n  home: '<svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" height=\"25\" viewBox=\"0 0 18 18\" width=\"25\"><path fill=\"#6E6E6E\" d=\"M17.666,10.125,9.375,1.834a.53151.53151,0,0,0-.75,0L.334,10.125a.53051.53051,0,0,0,0,.75l.979.9785A.5.5,0,0,0,1.6665,12H2v4.5a.5.5,0,0,0,.5.5h4a.5.5,0,0,0,.5-.5v-5a.5.5,0,0,1,.5-.5h3a.5.5,0,0,1,.5.5v5a.5.5,0,0,0,.5.5h4a.5.5,0,0,0,.5-.5V12h.3335a.5.5,0,0,0,.3535-.1465l.979-.9785A.53051.53051,0,0,0,17.666,10.125Z\"/></svg>',\n};\n\n// split arrays based on a predicate\n// unlike string.prototype.split, it works on\n// all arrays.\nexport const split = <T>(\n  predicate: (_: T) => boolean\n) => (arr: T[]): T[][] => {\n  const splitArrays = [];\n  let currSubArray = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (predicate(arr[i])) {\n      splitArrays.push(currSubArray);\n      currSubArray = [];\n      continue;\n    }\n    currSubArray.push(arr[i]);\n  }\n  splitArrays.push(currSubArray);\n  return splitArrays;\n};\n\nexport const takeWhile = <T>(\n  predicate: (_: T) => boolean\n) => (arr: T[]): T[] => {\n  if (arr.length === 0)\n    return arr;\n  const [firstItem, ...remainingItems] = arr;\n  if (predicate(firstItem))\n    return [firstItem].concat(takeWhile(predicate)(remainingItems));\n  return [];\n};\n\nexport const dropWhile = <T>(\n  predicate: (_: T) => boolean\n) => (arr: T[]): T[] => {\n  if (arr.length === 0)\n    return arr;\n  const [firstItem, ...remainingItems] = arr;\n  if (predicate(firstItem))\n    return dropWhile(predicate)(remainingItems);\n  return remainingItems;\n};\n\nexport const getNextSiblings = (element: Element): Element[] => {\n  const accumulator = [];\n  let iterator = element.nextElementSibling as Element ?? null;\n  while(iterator !== null) {\n    accumulator.push(iterator);\n    iterator = iterator.nextElementSibling as Element ?? null;\n  }\n  return accumulator;\n};\n\ntype Alternative<ReturnType, InputType> = {\n  or: (\n    fallbackFn: (input: InputType) => ReturnType\n  ) => Alternative<ReturnType, InputType>;\n  eval: (input: InputType) => ReturnType;\n};\n\nexport const alternative = <ReturnType, InputType>(\n  primaryFn: (input: InputType) => ReturnType\n): Alternative<ReturnType, InputType> => {\n  return {\n    eval: primaryFn,\n    or: (fallbackFn) => alternative((input) => {\n      try {\n        return primaryFn(input)\n      } catch (_error) {\n        return fallbackFn(input);\n      }\n    })\n  }\n};\n\nexport const parseListAndAccumulateErrors = <\n  UnParsedObj,\n  ParsedObj,\n  ErrorType\n  >(\n  elements: List<UnParsedObj>,\n  parse: (element: UnParsedObj) => Parsed<ParsedObj, ErrorType>\n): Parsed<List<ParsedObj>, ErrorType> => elements.reduce(\n  ([accElems, accErrors], element) => {\n    try {\n      const [parsedElement, parseErrors] = parse(element);\n      return [\n        [...accElems, parsedElement],\n        [...accErrors, ...parseErrors]\n      ];\n    } catch (error) {\n      if (error instanceof IrrecoverableError) {\n        return [accElems, [\n          error as ErrorType,\n          ...accErrors]\n        ];\n      }\n      return [accElems, accErrors];\n    }\n  },\n  [[],[]] as Parsed<List<ParsedObj>, ErrorType>\n  );\n\ntype CleanupFunction = () => void;\ntype AddListeners = (gnav: HTMLElement) => CleanupFunction;\ntype ListenerSetupFunctions = {\n  mobileEventListeners: AddListeners;\n  desktopEventListeners: AddListeners;\n}\nexport const setupMobileDesktopListeners = ({\n  mobileEventListeners,\n  desktopEventListeners\n}: ListenerSetupFunctions) => (gnav: HTMLElement): void => {\n  let cleanup: CleanupFunction;\n  if (isDesktop.matches)\n    cleanup = desktopEventListeners(gnav);\n  else\n    cleanup = mobileEventListeners(gnav);\n\n  isDesktop.addEventListener('change', () => {\n    cleanup?.();\n    cleanup\n      = isDesktop.matches\n      ? desktopEventListeners(gnav)\n      : mobileEventListeners(gnav);\n  });\n};\n\nexport const fetchAndProcessPlainHTML = async (\n  source: URL | null\n): Promise<HTMLElement | IrrecoverableError> => {\n  try {\n    if (source === null)\n      return new IrrecoverableError('URL is null');\n    const response = await fetch(federateUrl(source.href));\n    if (!response.ok)\n      return new IrrecoverableError(`Request for ${source} failed`);\n    const htmlText = await response.text();\n  \n    const { body } = new DOMParser().parseFromString(htmlText, \"text/html\");\n    return body;\n  } catch (error) {\n    return new IrrecoverableError(JSON.stringify(error));\n  }\n};\n\nconst federateUrl = (path: string): string => {\n  // Prevent double .plain.html by first removing any existing\n  // .plain.html, then adding it back\n  const cleanedPath = path.replace(/\\.plain\\.html(?=[?#]|$)/, '.html');\n  // Handles .html, .html#hash, .html?query, or no extension\n  return cleanedPath.replace(/\\.html(?=[?#]|$)|(?=[?#]|$)/, '.plain.html');\n}\n\nexport const inlineNestedFragments = async (\n  element: Element | HTMLElement\n): Promise<Element | HTMLElement | IrrecoverableError> => {\n  const processElement = async (\n    currentElem: Element | HTMLElement | IrrecoverableError,\n    visitedUrls: Set<string>\n  ): Promise<Element | HTMLElement | IrrecoverableError> => {\n    if (currentElem instanceof IrrecoverableError)\n      return currentElem;\n    try {\n      const anchorElements = [\n        ...currentElem.querySelectorAll('a[href*=\"#_inline\"]')\n      ] as HTMLAnchorElement[];\n      const inlineLinks = anchorElements\n        .map(async (anchorElement: HTMLAnchorElement) => {\n          try {\n            if (visitedUrls.has(anchorElement.href)) return;\n            const federatedUrl = federateUrl(anchorElement.href);\n            const fragmentUrl = new URL(federatedUrl);\n            const fragmentBody = await fetchAndProcessPlainHTML(fragmentUrl);\n            visitedUrls.add(anchorElement.href);\n            if (fragmentBody instanceof IrrecoverableError)\n              throw fragmentBody;\n            await processElement(fragmentBody, visitedUrls);\n            const parentDiv = anchorElement.closest('div');\n            if (parentDiv) {\n              parentDiv.replaceChildren(...fragmentBody.children);\n            }\n            return;\n          } catch {\n            return;\n          }\n        }, [] as List<[HTMLAnchorElement, URL]>)\n      await Promise.all(inlineLinks);\n      return currentElem\n    } catch (error) {\n      return new IrrecoverableError(JSON.stringify(error));\n    }\n  }\n  return processElement(element, new Set());\n};\n\nexport const renderListItems = <T>(\n  items: T[],\n  renderFn: (item: T) => string\n): string => {\n  return items.map(item => `<li>${renderFn(item)}</li>`).join('');\n};\n\nexport const sanitize = (str: string): string => {\n  return str\n    .toLowerCase()\n    .trim()\n    // Replace spaces and non-alphanumeric characters with hyphens\n    .replace(/[^a-z0-9]/g, '-')\n    // Remove multiple consecutive hyphens\n    .replace(/-+/g, '-')\n    // Remove leading/trailing hyphens\n    .replace(/^-+|-+$/g, '')\n    // Ensure it starts with a letter (prepend 'id-' if it starts with a number)\n    .replace(/^(\\d)/, 'id-$1')\n};\n", "import { Column, ColumnItem, MenuPromo, MultiColumnSection, SingleColumnSection, SingleColumnSectionList } from \"./Parse\";\nimport { linkGroup } from \"../LinkGroup/Render\";\nimport { link } from \"../Link/Render\";\nimport { primaryCTA, secondaryCTA } from \"../CTA/Render\";\nimport { renderListItems } from \"../../Utils/Utils\";\n\nexport const column = (\n  c: Column\n): HTML => {\n  switch(c.type) {\n    case \"SingleColumnSection\":\n      return singleColumnSection(c);\n    case \"SingleColumnSectionList\":\n      return singleColumnSectionList(c);\n    case \"MultiColumnSection\":\n      return multiColumnSection(c);\n    case \"MenuPromo\":\n      return menuPromo(c);\n    default: {\n      const exhaustive: never = c;\n      console.error(`Unexpected Column Type ${exhaustive}`);\n      return \"\";\n    }\n  }\n}\n\nconst singleColumnSection = ({\n  title,\n  items,\n}: SingleColumnSection): HTML => `\n<ul>\n  ${title === null\n    ? ''\n    : `<span class=\"column-section-title\">${title}</span>`\n  }\n  ${renderListItems(items, columnItem)}\n</ul>\n`;\n\nconst singleColumnSectionList = ({\n  sections\n}: SingleColumnSectionList): HTML => `\n  <ul>\n    ${renderListItems(sections, singleColumnSection)}\n  </ul>\n`;\n\nconst multiColumnSection = ({\n  title,\n  columns\n}: MultiColumnSection): HTML => `\n  <ul>\n  ${title === null\n    ? ''\n    : `<span class=\"column-section-title\">${title}</span>`\n  }\n  ${renderListItems(\n    columns, \n    (columnItemList) => renderListItems(columnItemList, columnItem))\n  }\n  </ul>\n`\nexport const menuPromo = ({\n  content\n}: MenuPromo): HTML => content\n\nconst columnItem = (\n  item: ColumnItem\n): HTML => {\n  switch (item.type) {\n    case \"LinkGroupHeader\":\n    case \"LinkGroupLink\":\n    case \"LinkGroupBlue\":\n      return linkGroup(item);\n    case \"Link\":\n      return link(item);\n    case \"PrimaryCTA\":\n      return primaryCTA(item);\n    case \"SecondaryCTA\":\n      return secondaryCTA(item);\n    default: {\n      const exhaustive: never = item;\n      console.error(`Unexpected ColumnItem type ${exhaustive}`);\n      return \"\";\n    }\n  }\n}\n", "import { RecoverableError } from \"../../Error/Error\";\n\nexport type Brand = {\n  type: \"Brand\";\n  imgSrc: string;\n  altText: string;\n  render: boolean;\n  brandImageOnly: boolean;\n  href: URL;\n};\n\n// TODO: Implement this for real.\nexport const parseBrand = (\n  _element: Element | null,\n): Parsed<Brand, RecoverableError> => {\n  return [\n    {\n      type: \"Brand\",\n      imgSrc: \"/federal/assets/svgs/adobe-logo.svg\",\n      altText: \"Adobe .Inc.\",\n      render: true,\n      brandImageOnly: true,\n      href: new URL('https://www.adobe.com')\n    },\n    []\n  ]\n};\n", "import { Brand } from \"./Parse\";\n\nexport const brand = ({\n  imgSrc,\n  altText,\n  href\n}: Brand): HTML => `\n<a href=\"${href.href}\" \n   class=\"feds-brand\"\n   aria-label=\"Adobe\"\n>\n <img src=\"${imgSrc}\" alt=\"${altText}\" loading=\"lazy\"> \n</a>\n`;\n", "import { IrrecoverableError, RecoverableError } from \"../../Error/Error\";\n\nexport type Link = {\n  type: 'Link';\n  text: string;\n  href: string;\n};\n\nconst ERRORS = {\n  elementNull: \"Error when parsing Link. Element is null\",\n  notAnchor: \"Cannot parse non-anchor as Link\",\n  textContentNotFound: \"Error when parsing Link. Element has no textContent\",\n  hrefNotFound: \"Element has no href\",\n}\n\nexport const parseLink = (\n  anchor: Element | null\n): Parsed<Link, RecoverableError> => {\n  if (anchor === null)\n    throw new IrrecoverableError(ERRORS.elementNull);\n\n  if (anchor.tagName !== 'A')\n    throw new IrrecoverableError(ERRORS.notAnchor);\n\n  const text = anchor?.textContent ?? '';\n  if (text === '')\n    throw new IrrecoverableError(ERRORS.textContentNotFound)\n\n  const href = anchor?.getAttribute(\"href\") ?? '';\n  if (href === '')\n    throw new IrrecoverableError(ERRORS.hrefNotFound);\n\n  return [\n    {\n      type: \"Link\",\n      text,\n      href\n    },\n    []\n  ];\n};\n", "import { RecoverableError } from \"../../Error/Error\";\nimport { alternative } from \"../../Utils/Utils\";\nimport { parseLink } from \"../Link/Parse\";\n\nexport type PrimaryCTA = {\n  type: \"PrimaryCTA\";\n  text: string;\n  href: string;\n};\n\nexport type SecondaryCTA = {\n  type: \"SecondaryCTA\";\n  text: string;\n  href: string;\n};\n\nexport type ProductEntryCTA = PrimaryCTA | SecondaryCTA;\n\nconst parseCTA = (\n  type: Pick<CTA, 'type'>\n) => (\n  element: Element | null\n): Parsed<CTA, RecoverableError> => {\n  if (element === null)\n    throw new Error('');\n\n  const anchor = element.querySelector(getSelector(type));\n  if (!anchor)\n    throw new Error('');\n\n  const [{ text, href }, es] = parseLink(anchor);\n  return [\n    {\n      type: type.type,\n      text,\n      href,\n    },\n    es\n  ]\n}\n\nexport const parsePrimaryCTA = parseCTA({ type: \"PrimaryCTA\" });\n\nexport const parseSecondaryCTA = parseCTA({ type: \"SecondaryCTA\" });\n\nexport const parseProductEntryCTA = (\n  element: Element | null\n): Parsed<ProductEntryCTA, RecoverableError> => alternative(parsePrimaryCTA)\n  .or(parseSecondaryCTA)\n  .eval(element);\n\ntype CTA\n  = PrimaryCTA\n  | SecondaryCTA;\n\nconst getSelector = ({ type }: Pick<CTA, 'type'>): string => {\n  switch (type) {\n    case \"PrimaryCTA\": return 'strong > a';\n    case \"SecondaryCTA\": return 'em > a';\n    default: throw new Error('');\n  }\n}\n\n", "import { IrrecoverableError, RecoverableError } from \"../../Error/Error\";\nimport { alternative } from \"../../Utils/Utils\";\nimport { Link, parseLink } from \"../Link/Parse\";\n\nexport type LinkGroupHeader = {\n  type: \"LinkGroupHeader\";\n  title: string;\n  classes: string[];\n};\n\nexport type LinkGroupLink = {\n  type: \"LinkGroupLink\";\n  iconHref: string | null;\n  iconAlt: string | null;\n  title: string;\n  href: string;\n  subtitle: string;\n}\n\nexport type LinkGroupBlue = {\n  type: \"LinkGroupBlue\";\n  link: Link;\n};\n\nexport type LinkGroup\n  = LinkGroupHeader\n  | LinkGroupLink\n  | LinkGroupBlue;\n\n\nexport const parseLinkGroup = (\n  element: Element | null\n): Parsed<LinkGroup, RecoverableError> => \n  alternative(parseLinkGroupHeader)\n    .or(parseLinkGroupLink)\n    .or(parseLinkGroupBlue)\n    .eval(element);\n\n/* example structure of a link group\n*\n* <div class=\"link-group\">\n*   <div>\n*     <div><a href=\"/federal/assets/svgs/creative-cloud-40.svg\">https://main--federal--adobecom.hlx.page/federal/assets/svgs/creative-cloud-40.svg | Adobe Creative Cloud</a></div>\n*     <div>\n*       <p><a href=\"https://www.adobe.com/creativecloud.html\">What is Creative Cloud?</a></p>\n*       <p>Creative apps and services for everyone</p>\n*     </div>\n*   </div>\n* </div>\n*  \n* Sometimes it's slightly different\n* <div class=\"link-group gray-gradient bold header\">\n    <div>\n      <div></div>\n      <div>\n        <h5 id=\"document-productivity\"><a href=\"bookmark://_document-productivity\">Document productivity</a></h5>\n      </div>\n    </div>\n  </div>\n*\n*/\n\nconst ERRORS = {\n  elementNull: \"Element not found\",\n  noTitleAnchor: \"Title anchor not found\",\n  noHref: \"Title Anchor has no href\",\n  noTitle: \"Title text not found\",\n  noSubtitleP: \"Subtitle <p> not found\",\n  noSubtitle: \"Subtitle text not found\",\n  notAHeader: \"Expected a Header class\",\n};\n\nconst parseLinkGroupLink = (\n  element: Element | null\n): Parsed<LinkGroup, RecoverableError> => {\n  const errors = new Set<RecoverableError>();\n  if (!element)\n    throw new IrrecoverableError(ERRORS.elementNull);\n\n  const titleElement = element.querySelector(\"p a\");\n  if (!titleElement)\n    throw new IrrecoverableError(ERRORS.noTitleAnchor);\n\n  const title = titleElement.textContent ?? '';\n  if (title === '')\n    errors.add(new RecoverableError(ERRORS.noTitle));\n\n  const href = titleElement.getAttribute(\"href\") ?? '';\n  if (href === '')\n    errors.add(new RecoverableError(ERRORS.noHref));\n\n  const subtitleElement = titleElement\n    ?.closest(\"p\")\n    ?.nextElementSibling;\n  if (!subtitleElement)\n    throw new IrrecoverableError(ERRORS.noSubtitleP);\n\n  const subtitle = subtitleElement.textContent ?? '';\n  if (subtitle === '')\n    errors.add(new RecoverableError(ERRORS.noSubtitle));\n\n  const [iconHref = null, iconAlt = null] = (element\n    .firstElementChild\n    ?.firstElementChild\n    ?.textContent\n    ?.split(\"|\") ?? []).map(x => x.trim());\n  return [\n    {\n      type: \"LinkGroupLink\",\n      iconHref,\n      iconAlt,\n      title,\n      href,\n      subtitle\n    },\n    [...errors]\n  ]\n}\n\nconst parseLinkGroupHeader = (\n  element: Element | null\n): Parsed<LinkGroup, RecoverableError> => {\n  if (!element)\n    throw new IrrecoverableError(ERRORS.elementNull);\n  \n  const classes = [...element.classList];\n\n  if(!classes.includes('header'))\n    throw new IrrecoverableError(ERRORS.notAHeader);\n\n  const title = element.querySelector('h5')?.textContent ?? \"\";\n  if(title === \"\")\n    throw new IrrecoverableError(ERRORS.noTitle);\n\n  return [\n    {\n      type: \"LinkGroupHeader\",\n      title,\n      classes,\n    },\n    []\n  ];\n};\n\nconst parseLinkGroupBlue = (\n  element: Element | null\n): Parsed<LinkGroup, RecoverableError> => {\n  if (!element)\n    throw new IrrecoverableError(ERRORS.elementNull);\n\n  if (!element.classList.contains('blue'))\n    throw new Error('Not a Blue Link Group');\n\n  const a = element.querySelector('a');\n  const [link, es] = parseLink(a);\n\n  return [\n    {\n      type: \"LinkGroupBlue\",\n      link\n    },\n    es\n  ];\n};\n", "import { IrrecoverableError, RecoverableError } from \"../../Error/Error\";\nimport { alternative, getNextSiblings, parseListAndAccumulateErrors, split, takeWhile } from \"../../Utils/Utils\";\nimport { parsePrimaryCTA, parseSecondaryCTA, PrimaryCTA, SecondaryCTA } from \"../CTA/Parse\";\nimport { Link, parseLink } from \"../Link/Parse\";\nimport { LinkGroup, parseLinkGroup } from \"../LinkGroup/Parse\";\n\nexport type Column\n  = SingleColumnSection\n  | SingleColumnSectionList\n  | MultiColumnSection\n  | MenuPromo;\n\ntype ColumnParser = (_: Element)\n  => Parsed<Column, RecoverableError>;\n\nexport const parseColumn = (\n  el: Element\n): Parsed<Column, RecoverableError> =>\n  alternative(parseSingleColumnSectionList as ColumnParser)\n    .or(parseSingleColumnSection)\n    .or(parseMultiColumnSection)\n    .or(parseMenuPromo)\n    .eval(el);\n\nexport type ColumnItem\n  = LinkGroup\n  | Link\n  | PrimaryCTA\n  | SecondaryCTA;\n\nconst parseColumnItems = (\n  items: List<Element>\n): Parsed<List<ColumnItem>, RecoverableError> =>\n  parseListAndAccumulateErrors(items, (item) =>\n    alternative(\n      parseLinkGroup as (_: Element) => Parsed<ColumnItem, RecoverableError>)\n      .or(parsePrimaryCTA)\n      .or(parseSecondaryCTA)\n      .or(parseLink)\n      .eval(item)\n  );\n\nconst extractColumnItems = (\n  elements: List<Element>\n): List<Element> =>\n  elements.flatMap(item => {\n    if (item.nodeName === 'UL')\n      return [...item.querySelectorAll('li > a')];\n    return [item];\n  });\n\nexport type SingleColumnSection = {\n  type: \"SingleColumnSection\";\n  title: string | null;\n  items: List<ColumnItem>;\n};\n\nconst parseSingleColumnSection = (\n  element: Element\n): Parsed<SingleColumnSection, RecoverableError> => {\n  if (element.querySelector('.column-break'))\n    throw new IrrecoverableError(\"Has a column break\");\n\n  const h5 = element.firstElementChild;\n  if (h5 === null)\n    throw new IrrecoverableError(\"No Children\"); // TODO put this into ERRORS\n\n  const title\n    = h5.nodeName === 'H5'\n    ? (h5.textContent ?? null)\n    : null\n  const columnItems\n    = h5.nodeName === 'H5'\n    ? getNextSiblings(h5)\n    : [...element.children];\n  const rawLinks = extractColumnItems(columnItems);\n  const [items, es] = parseColumnItems(rawLinks);\n\n  return [\n    {\n      type: \"SingleColumnSection\",\n      title,\n      items\n    },\n    es\n  ];\n}\n\nexport type SingleColumnSectionList = {\n  type: \"SingleColumnSectionList\";\n  sections: List<SingleColumnSection>;\n};\n\nexport const parseSingleColumnSectionList = (\n  element: Element\n): Parsed<SingleColumnSectionList, RecoverableError> => {\n  if (element.querySelector('.column-break'))\n    throw new IrrecoverableError(\"Has a column break\");\n\n  const h5s = [...element.querySelectorAll('h5')];\n  if (h5s.length <= 1)\n    throw new IrrecoverableError(\"Not a section list\");\n\n  const parseSection = (\n    h5: Element\n  ): Parsed<SingleColumnSection, RecoverableError> => {\n    const container = document.createElement('div');\n    const listItems = \n      takeWhile(\n        (x: Element) =>\n          x.nodeName !== 'H5')(getNextSiblings(h5));\n    container.append(h5, ...listItems);\n    return parseSingleColumnSection(container);\n  };\n  const [sections, es]\n    = parseListAndAccumulateErrors(h5s, parseSection);\n\n  return [\n    {\n      type: \"SingleColumnSectionList\",\n      sections\n    },\n    es\n  ];\n};\n\nexport type MultiColumnSection = {\n  type: \"MultiColumnSection\";\n  title: string;\n  columns: List<List<ColumnItem>>;\n};\n\nconst parseMultiColumnSection = (\n  element: Element\n): Parsed<MultiColumnSection, RecoverableError> => {\n  if (!element.querySelector('.column-break'))\n    throw new IrrecoverableError(\"Expected a Column Break\");\n  const h5 = element.firstElementChild;\n  if (h5 === null || h5.nodeName !== 'H5')\n    throw new IrrecoverableError(ERRORS.expectedH5);\n  const title = h5.textContent;\n  if (title === '' || title === null)\n    throw new IrrecoverableError(ERRORS.emptyTitle);\n\n  const isColumnBreak = (x: Element): boolean =>\n    x.classList.contains('column-break')\n  const rawColumns =\n    split(isColumnBreak)(getNextSiblings(h5))\n      .map(extractColumnItems);\n  const [columns, es] =\n    parseListAndAccumulateErrors(rawColumns, parseColumnItems);\n\n  return [\n    {\n      type: \"MultiColumnSection\",\n      title,\n      columns\n    },\n    es\n  ];\n};\n\nexport type MenuPromo = {\n  type: \"MenuPromo\";\n  content: HTML;\n};\n\nexport const parseMenuPromo = (\n  element: Element | null\n): Parsed<MenuPromo, RecoverableError> => {\n  if (element === null)\n    throw new IrrecoverableError(ERRORS.elementNull);\n  // TODO: Should gnav-image be treated differently?\n  const promo = element.querySelector('.gnav-promo, .gnav-image');\n  if (promo === null)\n    throw new IrrecoverableError(ERRORS.noPromo);\n  const content = promo.innerHTML ?? '';\n  if (content === '')\n    throw new IrrecoverableError(ERRORS.noPromoContent);\n  return [\n    {\n      type: \"MenuPromo\",\n      content\n    },\n    []\n  ]\n};\n\nconst ERRORS = {\n  expectedH5: \"Expected an H5 element for the title \",\n  emptyTitle: \"Expected Title to not be empty\",\n  elementNull: \"Element is null\",\n  noPromo: \"Promo or gnav image not found\",\n  noPromoContent: \"Promo Content not found\",\n};\n", "import { IrrecoverableError, RecoverableError } from \"../../Error/Error\";\nimport { fetchAndProcessPlainHTML, inlineNestedFragments, parseListAndAccumulateErrors } from \"../../Utils/Utils\";\nimport { Column, parseColumn } from \"../Column/Parse\";\nimport { Link, parseLink } from \"../Link/Parse\";\n\n\nexport type MegaMenu = {\n  type: \"MegaMenu\";\n  title: string;\n  columns: Promise<Parsed<List<Column>, RecoverableError>>;\n  crossCloudMenu: List<Link>;\n  isSection: boolean;\n};\n\n\nexport const parseMegaMenu = (\n  element: Element | null\n): Parsed<MegaMenu, RecoverableError> => {\n  const errors = new Set<RecoverableError>();\n  if (element === null)\n    throw new IrrecoverableError(ERRORS.elementNull);\n\n  const title = element.querySelector('h2')?.textContent ?? \"\";\n  if (title === \"\")\n    errors.add(new RecoverableError(ERRORS.noTitle))\n\n  const columns = (async (): \n                   Promise<Parsed<List<Column>, RecoverableError>> => {\n    try {\n      const fragment: HTMLAnchorElement | null = element.querySelector('h2 > a');\n      const fragmentURL = new URL(fragment?.href ?? \"\");\n      const initialFragment =\n        await fetchAndProcessPlainHTML(fragmentURL);\n      if (initialFragment instanceof IrrecoverableError)\n        throw new Error(initialFragment.message);\n      const megaMenuFragment = await inlineNestedFragments(initialFragment);\n      if (megaMenuFragment instanceof IrrecoverableError)\n        throw new Error(megaMenuFragment.message);\n      const unparsedColumns = [...megaMenuFragment.children]\n        .map(c => c.firstElementChild ?? c);\n      unparsedColumns.forEach(c => console.log(c.outerHTML));\n      return parseListAndAccumulateErrors(\n        unparsedColumns,\n        parseColumn\n      );\n    } catch (e) {\n        throw new IrrecoverableError(JSON.stringify(e));\n    }\n  })();\n  const unparsedCrossCloud = element.querySelectorAll(\n    '.cross-cloud-menu ul > li > a'\n  );\n  const [crossCloudMenu, ccmErrors] = parseListAndAccumulateErrors(\n    [...unparsedCrossCloud],\n    parseLink\n  );\n\n  const isSection = element.classList.contains('section');\n\n  return [\n    {\n      type: \"MegaMenu\",\n      title,\n      columns,\n      crossCloudMenu,\n      isSection\n    },\n    [\n      ...ccmErrors,\n      ...errors\n    ]\n  ]\n};\n\nconst ERRORS = {\n  elementNull: \"Element is null\",\n  noTitle: \"Large Menu has no Title\",\n};\n", "import { MegaMenu } from \"./Parse\";\nimport { renderListItems, sanitize } from \"../../Utils/Utils\";\nimport { link } from \"../Link/Render\";\n\nexport const renderGhostColumns = (): HTML => `\n  <li class=\"ghost-column\">\n    <div class=\"ghost-header\"></div>\n    <div class=\"ghost-item\"></div>\n    <div class=\"ghost-item\"></div>\n    <div class=\"ghost-item\"></div>\n  </li>\n  <li class=\"ghost-column\">\n    <div class=\"ghost-header\"></div>\n    <div class=\"ghost-item\"></div>\n    <div class=\"ghost-item\"></div>\n    <div class=\"ghost-item\"></div>\n  </li>\n  <li class=\"ghost-column\">\n    <div class=\"ghost-header\"></div>\n    <div class=\"ghost-item\"></div>\n    <div class=\"ghost-item\"></div>\n  </li>\n`;\n\n/* \n* We don't render columns immediately\n* So that we can deal with the ghost state\n* and so on.\n*/\n      \nexport const megaMenu = ({\n  title,\n  crossCloudMenu,\n  isSection\n}: MegaMenu): HTML => `\n  <button type=\"button\"\n          aria-expanded=\"false\"\n          aria-controls=\"${sanitize(title)}\"\n          class=\"mega-menu\"\n  >\n    ${title}\n  </button>\n  <div id=\"${sanitize(title)}\" class=\"feds-popup${isSection ? '' : ' section'}\">\n    <ul>\n    </ul>\n    <ul class=\"cross-cloud-menu\">\n      ${renderListItems(crossCloudMenu, link)}\n    </ul>\n  </div>\n`\n", "import { IrrecoverableError, RecoverableError } from \"../../Error/Error\";\nimport { alternative, getNextSiblings, parseListAndAccumulateErrors } from \"../../Utils/Utils\";\nimport { MenuPromo, parseMenuPromo, parseSingleColumnSectionList, SingleColumnSectionList } from \"../Column/Parse\";\nimport { Link, parseLink } from \"../Link/Parse\";\n\nexport type SmallMenu = {\n  type: \"SmallMenu\";\n  title: string;\n  columns: SingleColumnSectionList | List<List<Link>>;\n  promo: MenuPromo | null;\n};\n\ntype ColumnParser = (\n  _: Element\n) => Parsed<SingleColumnSectionList | List<List<Link>>, RecoverableError>;\n\nexport const parseSmallMenu = (\n  element: Element | null\n): Parsed<SmallMenu, RecoverableError> => {\n  const errors = [];\n  if (element === null)\n    throw new IrrecoverableError(ERRORS.elementNull);\n\n  const h2 = element.querySelector('h2')\n  const title = h2?.textContent ?? \"\";\n  if (title === \"\")\n    errors.push(new RecoverableError(ERRORS.noTitle))\n\n  const columnsContainer = ((): Element => {\n    if (h2 === null)\n      return element;\n    const container = document.createElement('div');\n    getNextSiblings(h2).forEach(s => container.appendChild(s));\n    return container;\n  })();\n  const [columns, es]\n    = alternative(parseSingleColumnSectionList as ColumnParser)\n    .or((el) => parseListAndAccumulateErrors(\n      [...el.children],\n      parseNoTitleColumn\n    )).eval(columnsContainer);\n  \n  const [promo, pes] = ((): Parsed<MenuPromo | null, RecoverableError> => {\n    try {\n      return parseMenuPromo(element);\n    } catch (_) {\n      return [null, []];\n    }\n  })();\n\n  return [\n    {\n      type: \"SmallMenu\",\n      title,\n      columns,\n      promo\n    },\n    [\n      ...es,\n      ...pes\n    ]\n  ];\n};\n\nconst parseNoTitleColumn = (\n  element: Element\n): Parsed<List<Link>, RecoverableError> => {\n  if (element.nodeName !== 'UL')\n    throw new Error('');\n  const links = [...element.querySelectorAll('ul > li > a')];\n  return parseListAndAccumulateErrors(links, parseLink);\n};\n\nconst ERRORS = {\n  elementNull: \"The element to be parsed is null\",\n  noTitle: \"Small menu has no title\",\n}\n", "import { renderListItems, sanitize } from \"../../Utils/Utils\";\nimport { SingleColumnSectionList } from \"../Column/Parse\";\nimport { column, menuPromo } from \"../Column/Render\";\nimport { Link } from \"../Link/Parse\";\nimport { link } from \"../Link/Render\";\nimport { SmallMenu } from \"./Parse\";\n\nexport const smallMenu = ({\n  title,\n  columns,\n  promo\n}: SmallMenu): HTML => `\n  <button type=\"button\"\n          aria-expanded=\"false\"\n          aria-controls=\"${sanitize(title)}\"\n  >\n    ${title}\n  </button>\n  <div class=\"feds-popup\" id=\"${sanitize(title)}\">\n    ${smallMenuList(columns)}\n    ${promo === null ? '' : `<li>${menuPromo(promo)}</li>`}\n  </div>\n`;\n\nconst smallMenuList = (\n  c: SingleColumnSectionList | List<List<Link>>\n): HTML => {\n  if (!Array.isArray(c) && c?.type === \"SingleColumnSectionList\")\n    return column(c);\n  return `\n  <ul>\n    ${renderListItems(c as List<List<Link>>, (l) => `\n      <ul>\n        ${renderListItems(l, link)}\n      </ul>\n    `)}\n  </ul>\n  `;\n}\n", "import { RecoverableError } from \"../../Error/Error\";\n\nexport type Text = {\n  type: \"Text\";\n  content: string;\n};\n\nconst ERRORS = {\n  elementNull: \"Error when parsing text. Element is null\",\n  textContentNull: \"Error when parsing text. Element has no textContent\",\n}\n\nexport const parseText = (\n  element: Element | null\n): Parsed<Text, RecoverableError> => {\n  if (element === null)\n    return [\n      {\n        type: \"Text\" ,\n        content: \"\"\n      },\n      [new RecoverableError(ERRORS.elementNull, \"Minor\")]\n    ];      \n  const content = element.textContent;\n  if (content === null)\n    return [\n      {\n        type: \"Text\",\n        content: \"\",\n      },\n      [new RecoverableError(ERRORS.textContentNull, \"Minor\")]\n    ];\n  return [\n    {\n      type: \"Text\",\n      content,\n    },\n    []\n  ]\n};\n\n", "import { Text } from \"./Parse\";\n\nexport const text = ({ content }: Text): HTML => content;\n", "import { IrrecoverableError, RecoverableError } from \"../Error/Error\";\nimport { Brand, parseBrand } from \"./Brand/Parse\";\nimport { brand } from \"./Brand/Render\";\nimport { parsePrimaryCTA, parseSecondaryCTA, PrimaryCTA, SecondaryCTA } from \"./CTA/Parse\";\nimport { primaryCTA, secondaryCTA } from \"./CTA/Render\";\nimport { Link, parseLink } from \"./Link/Parse\";\nimport { link } from \"./Link/Render\";\nimport { MegaMenu, parseMegaMenu } from \"./MegaMenu/Parse\";\nimport { megaMenu } from \"./MegaMenu/Render\";\nimport { parseSmallMenu, SmallMenu } from \"./SmallMenu/Parse\";\nimport { smallMenu } from \"./SmallMenu/Render\";\nimport { parseText, Text } from \"./Text/Parse\";\nimport { text } from \"./Text/Render\";\n\nexport type Component\n  = Text\n  | Link\n  | SecondaryCTA\n  | PrimaryCTA\n  | Brand\n  | SmallMenu\n  | MegaMenu;\n\nexport const parseComponent = (\n  element: Element\n): Parsed<Component, RecoverableError> => {\n  if (element === null)\n    throw new IrrecoverableError(ERRORS.elementNull);\n\n  const brandElem = element.querySelector('.gnav-brand');\n  if (brandElem !== null) \n    return parseBrand(element)\n\n  const largeMenu = element.querySelector('.large-menu');\n  if (largeMenu !== null)\n    return parseMegaMenu(largeMenu);\n\n  if (element.querySelector('h5, ul, link-group') !== null)\n    return parseSmallMenu(element);\n\n  if (element.querySelector('strong') !== null)\n    return parsePrimaryCTA(element);\n  \n  if (element.querySelector('em') !== null)\n    return parseSecondaryCTA(element);\n\n  if (element.querySelector('a') === null)\n    return parseText(element);\n\n  return parseLink(element.querySelector('a'));\n};\n\nexport const component = (\n  c: Component\n): HTML => {\n  switch (c.type) {\n    case \"Text\": return text(c);\n    case \"Link\": return link(c);\n    case \"SecondaryCTA\": return secondaryCTA(c);\n    case \"PrimaryCTA\": return primaryCTA(c);\n    case \"Brand\": return brand(c);\n    case \"SmallMenu\": return smallMenu(c);\n    case \"MegaMenu\": return megaMenu(c);\n    default: {\n      const exhaustive : never = c;\n      console.error(`Failed to recognize component: ${exhaustive}`);\n      return '';\n    }\n  }\n};\n\nconst ERRORS = {\n  elementNull: \"Element is null\",\n};\n\n", "import { Component, parseComponent } from \"../Components/Component\";\nimport { parseProductEntryCTA, ProductEntryCTA } from \"../Components/CTA/Parse\";\nimport { Link, parseLink } from \"../Components/Link/Parse\";\nimport { IrrecoverableError, RecoverableError } from \"../Error/Error\";\nimport { parseListAndAccumulateErrors } from \"../Utils/Utils\";\n\nexport type GlobalNavigationData = {\n  breadcrumbs: List<Link>;\n  components: List<Component>;\n  productCTA: ProductEntryCTA | null;\n  localnav: boolean;\n  errors: List<RecoverableError>;\n};\n\nexport const parseNavigation = (\n  mainNav: HTMLElement\n): GlobalNavigationData | IrrecoverableError => {\n  const [breadcrumbs, breadcrumbErrors]\n    = parseListAndAccumulateErrors(\n      [...document.querySelectorAll('.breadcrumbs ul > li > a') ?? []],\n      parseLink\n    );\n  const [components, componentErrors] \n    = parseListAndAccumulateErrors(\n      [...mainNav.children],\n      parseComponent\n    ); \n  const productEntryElement = mainNav.querySelector('.product-entry-cta');\n  const [productCTA, productCtaErrors]\n    = (\n  (): Parsed<ProductEntryCTA | null, RecoverableError> => {\n    try {\n      return parseProductEntryCTA(productEntryElement);\n    } catch (_) {\n      return [null, []];\n    }\n  })();\n  const localnav = components\n    .filter((component): boolean =>\n            component.type === \"MegaMenu\" &&\n            component.isSection).length === 1;\n  const errors = [\n    breadcrumbErrors,\n    componentErrors,\n    productCtaErrors,\n  ].flat();\n\n  return {\n    breadcrumbs,\n    components,\n    productCTA,\n    localnav,\n    errors,\n  }\n};\n", "import { setupMobileDesktopListeners } from \"../Utils/Utils\";\n\ntype CleanupFunction = () => void\n\nconst mobileClickListeners = (\n  gnav: HTMLElement\n): CleanupFunction => {\n  return () => console.log(gnav);\n};\n\nconst desktopClickListeners = (\n  gnav: HTMLElement\n): CleanupFunction => {\n  return () => console.log(gnav);\n};\n\nexport const initClickListeners = setupMobileDesktopListeners({\n  mobileEventListeners: mobileClickListeners,\n  desktopEventListeners: desktopClickListeners,\n});\n\n", "import { setupMobileDesktopListeners } from \"../Utils/Utils\";\n\ntype CleanupFunction = () => void\n\nconst initDesktopKeyboardNav = (\n  gnav: HTMLElement\n): CleanupFunction => {\n  return () => console.log(gnav);\n};\n\nconst initMobileKeyboardNav = (\n  gnav: HTMLElement\n): CleanupFunction => {\n  return () => console.log(gnav);\n};\n\nexport const initKeyboardNav =  setupMobileDesktopListeners({\n  mobileEventListeners: initMobileKeyboardNav,\n  desktopEventListeners: initDesktopKeyboardNav,\n});\n", "import { IrrecoverableError } from \"../Error/Error\";\nimport { Input } from \"../Main\";\nimport { fetchAndProcessPlainHTML } from \"../Utils/Utils\";\n\ntype Initial = {\n  mainNav: HTMLElement;\n  aside: HTMLElement | IrrecoverableError;\n};\n\nexport const getInitialHTML = async ({\n  gnavSource,\n  asideSource\n}: Input): Promise<Initial | IrrecoverableError> => {\n  const mainNav = await fetchAndProcessPlainHTML(gnavSource);\n  if (mainNav instanceof IrrecoverableError)\n    return mainNav;\n  const aside = await fetchAndProcessPlainHTML(asideSource);\n  return {\n    mainNav,\n    aside,\n  }\n}\n\n", "import { column } from \"./Components/Column/Render\";\nimport { component } from \"./Components/Component\";\nimport { productEntryCTA } from \"./Components/CTA/Render\";\nimport { renderGhostColumns } from \"./Components/MegaMenu/Render\";\nimport { IrrecoverableError, RecoverableError } from \"./Error/Error\";\nimport { GlobalNavigationData, parseNavigation } from \"./Parse/Parse\";\nimport { initClickListeners } from \"./PostRendering/ClickListeners\";\nimport { initKeyboardNav } from \"./PostRendering/Keyboard\";\nimport { UnavConfig } from \"./PostRendering/Unav\";\nimport { getInitialHTML } from \"./PreRendering/FetchAssets\";\nimport { renderListItems } from \"./Utils/Utils\";\n\n\ntype GlobalNavigation = {\n  closeEverything: () => void;\n  reloadUnav: () => void;\n  getGnavTopPosition: () => number;\n  setGnavTopPosition: (_: number) => void;\n  errors: Set<RecoverableError>;\n};\n\nexport type Input = {\n  gnavSource: URL;\n  asideSource: URL | null;\n  gnavTop?: number;\n  isLocalNav: boolean;\n  mountpoint: HTMLElement;\n  unavEnabled: boolean;\n\n  getStageDomainMap: (domainmap: unknown[], env: string) =>\n    { [key: string]: string }\n  // MEP: {\n  //   commands: unknown;\n  //   handleCommands: (_: unknown) => unknown;\n  // }\n};\n\nexport const main = async (\n  input: Input\n): Promise<GlobalNavigation | IrrecoverableError> => {\n  const initial = await getInitialHTML(input)\n  if (initial instanceof IrrecoverableError)\n    return initial;\n  const { mainNav, aside: _aside } = initial;\n  if (mainNav instanceof IrrecoverableError)\n    return mainNav;\n\n  const gnavData = parseNavigation(mainNav);\n  if (gnavData instanceof IrrecoverableError)\n    return gnavData;\n  \n  // TODO: Implement Aside\n  \n  renderGnav(gnavData)(input.mountpoint);\n\n  return postRenderingTasks(input);\n};\n\n\nexport const renderGnav = (\n  data: GlobalNavigationData\n) => async (\nmountpoint: HTMLElement\n): Promise<HTMLElement> => {\n  const navHTML = renderGnavString(data)\n  mountpoint.innerHTML = navHTML;\n  const megaMenus = [\n    ...mountpoint.querySelectorAll('.mega-menu ~ .feds-popup > ul')\n  ]\n  megaMenus.forEach(mm => {\n    mm.innerHTML = renderGhostColumns();\n  });\n  const mmPromises = data.components\n    .filter(com => com.type === \"MegaMenu\")\n    .map(com => com.columns);\n  const _errors_ = await Promise.all(mmPromises.map(async (mmPromise, idx) => {\n    const [columns, errors] = await mmPromise;\n    const renderedColumns = renderListItems(columns, column);\n    megaMenus[idx].innerHTML = renderedColumns;\n    return errors;\n  }).flat());\n  return mountpoint;\n};\n\nexport const renderGnavString = ({\n  components,\n  productCTA,\n}: GlobalNavigationData\n): string => `\n<nav>\n  <ul>\n    ${renderListItems(components, component)}\n  </ul>\n  ${productCTA === null ? '' : productEntryCTA(productCTA)}\n  <div class=\"feds-utilities\">\n  </div>\n</nav>\n`;\n\n\nexport const postRenderingTasks = (\n  input: Input,\n): GlobalNavigation | IrrecoverableError => {\n  const errors = new Set<RecoverableError>();\n  const unav = loadUnav(input.mountpoint);\n  if (unav instanceof RecoverableError)\n    errors.add(unav);\n  else \n    unav.errors.forEach(errors.add);\n  initClickListeners(input.mountpoint);\n  initKeyboardNav(input.mountpoint);\n  \n  const reloadUnav\n    = unav instanceof RecoverableError\n    ? (): void => {}\n    : unav.reloadUnav;\n  return {\n    closeEverything,\n    reloadUnav,\n    errors,\n    setGnavTopPosition: (_): void => {},\n    getGnavTopPosition: (): number => 0\n  };\n};\n\ntype Unav = {\n  reloadUnav: (_?: UnavConfig) => void;\n  errors: Set<RecoverableError>;\n};\n\nconst loadUnav = (\n  _nav: HTMLElement,\n  _config?: UnavConfig\n): Unav | RecoverableError => {\n  return new RecoverableError(\"loadUnav has not been implemented yet\");\n};\n\nconst closeEverything = (): void => {\n};\n"],
  "mappings": "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",
  "names": ["linkGroup", "lg", "linkGroupHeader", "linkGroupLink", "linkGroupBlue", "title", "classes", "iconHref", "iconAlt", "href", "subtitle", "icon", "link", "link", "text", "href", "primaryCTA", "text", "href", "secondaryCTA", "productEntryCTA", "cta", "IrrecoverableError", "_IrrecoverableError", "message", "RecoverableError", "_RecoverableError", "severity", "isDesktop", "split", "predicate", "arr", "splitArrays", "currSubArray", "takeWhile", "firstItem", "remainingItems", "getNextSiblings", "element", "accumulator", "iterator", "alternative", "primaryFn", "fallbackFn", "input", "parseListAndAccumulateErrors", "elements", "parse", "accElems", "accErrors", "parsedElement", "parseErrors", "error", "IrrecoverableError", "setupMobileDesktopListeners", "mobileEventListeners", "desktopEventListeners", "gnav", "cleanup", "isDesktop", "fetchAndProcessPlainHTML", "source", "response", "federateUrl", "htmlText", "body", "path", "inlineNestedFragments", "processElement", "currentElem", "visitedUrls", "inlineLinks", "anchorElement", "federatedUrl", "fragmentUrl", "fragmentBody", "parentDiv", "renderListItems", "items", "renderFn", "item", "sanitize", "str", "column", "c", "singleColumnSection", "singleColumnSectionList", "multiColumnSection", "menuPromo", "title", "items", "renderListItems", "columnItem", "sections", "columns", "columnItemList", "content", "item", "linkGroup", "link", "primaryCTA", "secondaryCTA", "parseBrand", "_element", "brand", "imgSrc", "altText", "href", "ERRORS", "parseLink", "anchor", "IrrecoverableError", "text", "href", "parseCTA", "type", "element", "anchor", "getSelector", "text", "href", "es", "parseLink", "parsePrimaryCTA", "parseSecondaryCTA", "parseProductEntryCTA", "alternative", "parseLinkGroup", "element", "alternative", "parseLinkGroupHeader", "parseLinkGroupLink", "parseLinkGroupBlue", "ERRORS", "errors", "IrrecoverableError", "titleElement", "title", "RecoverableError", "href", "subtitleElement", "subtitle", "iconHref", "iconAlt", "x", "classes", "a", "link", "es", "parseLink", "parseColumn", "el", "alternative", "parseSingleColumnSectionList", "parseSingleColumnSection", "parseMultiColumnSection", "parseMenuPromo", "parseColumnItems", "items", "parseListAndAccumulateErrors", "item", "parseLinkGroup", "parsePrimaryCTA", "parseSecondaryCTA", "parseLink", "extractColumnItems", "elements", "element", "IrrecoverableError", "h5", "title", "columnItems", "getNextSiblings", "rawLinks", "es", "h5s", "parseSection", "container", "listItems", "takeWhile", "x", "sections", "ERRORS", "rawColumns", "split", "columns", "promo", "content", "parseMegaMenu", "element", "errors", "IrrecoverableError", "ERRORS", "title", "RecoverableError", "columns", "fragment", "fragmentURL", "initialFragment", "fetchAndProcessPlainHTML", "megaMenuFragment", "inlineNestedFragments", "unparsedColumns", "c", "parseListAndAccumulateErrors", "parseColumn", "e", "unparsedCrossCloud", "crossCloudMenu", "ccmErrors", "parseLink", "isSection", "renderGhostColumns", "megaMenu", "title", "crossCloudMenu", "isSection", "sanitize", "renderListItems", "link", "parseSmallMenu", "element", "errors", "IrrecoverableError", "ERRORS", "h2", "title", "RecoverableError", "columnsContainer", "container", "getNextSiblings", "s", "columns", "es", "alternative", "parseSingleColumnSectionList", "el", "parseListAndAccumulateErrors", "parseNoTitleColumn", "promo", "pes", "parseMenuPromo", "links", "parseLink", "smallMenu", "title", "columns", "promo", "sanitize", "smallMenuList", "menuPromo", "c", "column", "renderListItems", "l", "link", "ERRORS", "parseText", "element", "RecoverableError", "content", "text", "content", "parseComponent", "element", "IrrecoverableError", "ERRORS", "parseBrand", "largeMenu", "parseMegaMenu", "parseSmallMenu", "parsePrimaryCTA", "parseSecondaryCTA", "parseText", "parseLink", "component", "c", "text", "link", "secondaryCTA", "primaryCTA", "brand", "smallMenu", "megaMenu", "parseNavigation", "mainNav", "breadcrumbs", "breadcrumbErrors", "parseListAndAccumulateErrors", "parseLink", "components", "componentErrors", "parseComponent", "productEntryElement", "productCTA", "productCtaErrors", "parseProductEntryCTA", "localnav", "component", "errors", "mobileClickListeners", "gnav", "desktopClickListeners", "initClickListeners", "setupMobileDesktopListeners", "initDesktopKeyboardNav", "gnav", "initMobileKeyboardNav", "initKeyboardNav", "setupMobileDesktopListeners", "getInitialHTML", "gnavSource", "asideSource", "mainNav", "fetchAndProcessPlainHTML", "IrrecoverableError", "aside", "main", "input", "initial", "getInitialHTML", "IrrecoverableError", "mainNav", "_aside", "gnavData", "parseNavigation", "renderGnav", "postRenderingTasks", "data", "mountpoint", "navHTML", "renderGnavString", "megaMenus", "mm", "renderGhostColumns", "mmPromises", "com", "_errors_", "mmPromise", "idx", "columns", "errors", "renderedColumns", "renderListItems", "column", "components", "productCTA", "component", "productEntryCTA", "unav", "loadUnav", "RecoverableError", "initClickListeners", "initKeyboardNav", "reloadUnav", "closeEverything", "_", "_nav", "_config"]
}
